{
    "policy_based_ds": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "template <typename T> using ost = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;"
        ]
    },
    "vi": {
        "prefix": "vi",
        "body": "vector<int> $0"
    },
    "vl": {
        "prefix": "vl",
        "body": "vector<long long> $0"
    },
    "vpii": {
        "prefix": "vpii",
        "body": "vector<pair<int, int>> $0"
    },
    "vpll": {
        "prefix": "vpll",
        "body": "vector<pair<long long, long long> $0"
    },
    "vec": {
        "prefix": "vec",
        "body": "vector<$1> $0"
    },
    "si": {
        "prefix": "si",
        "body": "set<int> $0"
    },
    "sl": {
        "prefix": "sl",
        "body": "set<long long> $0"
    },
    "spii": {
        "prefix": "spii",
        "body": "set<pair<int, int>> $0"
    },
    "spll": {
        "prefix": "spll",
        "body": "set<pair<long long>> $0"
    },
    "st": {
        "prefix": "st",
        "body": "set<$1> $0"
    },
    "msi": {
        "prefix": "msi",
        "body": "multiset<int> $0"
    },
    "msl": {
        "prefix": "msl",
        "body": "multiset<long long> $0"
    },
    "mspii": {
        "prefix": "mspii",
        "body": "multiset<pair<int, int>> $0"
    },
    "mspll": {
        "prefix": "mspll",
        "body": "multiset<pair<long long>> $0"
    },
    "mst": {
        "prefix": "mst",
        "body": "multiset<$1> $0"
    },
    "min": {
        "prefix": "min",
        "body": "min($1, $2)$0"
    },
    "max": {
        "prefix": "max",
        "body": "max($1, $2)$0"
    },
    "pii": {
        "prefix": "pii",
        "body": "pair<int, int> $0"
    },
    "pll": {
        "prefix": "pll",
        "body": "pair<long long, long long> $0"
    },
    "pair": {
        "prefix": "pair",
        "body": "pair<$1, $1> $0"
    },
    "mapii": {
        "prefix": "mapii",
        "body": "map<int, int> $0"
    },
    "mapll": {
        "prefix": "mapll",
        "body": "map<long long> $0"
    },
    "map": {
        "prefix": "map",
        "body": "map<$1, $2> $0"
    },
    "pq": {
        "prefix": "pq",
        "body": "priority_queue<$1> $0"
    },
    "mpq": {
        "prefix": "mpq",
        "body": "priority_queue<$1, vector<$1>, greater<$1>> $0"
    },
    "qq": {
        "prefix": "qq",
        "body": "queue<$1> $0"
    },
    "dq": {
        "prefix": "dq",
        "body": "deque<$1> $0"
    },
    "stk": {
        "prefix": "stk",
        "body": "stk<$1> $0"
    },
    "str": {
        "prefix": "str",
        "body": "string $0"
    },
    "con": {
        "prefix": "con",
        "body": "contains($1)$0"
    },
    "new_line": {
        "prefix": "nl",
        "body": "'\\n'"
    },
    "space": {
        "prefix": "sp",
        "body": "' '"
    },
    "ll": {
        "prefix": "ll",
        "body": "long long"
    },
    "int128": {
        "prefix": "i128",
        "body": "__int128"
    },
    "pb": {
        "prefix": "pb",
        "body": "push_back($1)$0"
    },
    "eb": {
        "prefix": "eb",
        "body": "emplace_back($1)$0"
    },
    "bg": {
        "prefix": "beg",
        "body": "begin()"
    },
    "ed": {
        "prefix": "end",
        "body": "end()"
    },
    "all": {
        "prefix": "all",
        "body": "$1.begin(), $1.end()$0"
    },
    "lb": {
        "prefix": "lb",
        "body": "lower_bound($1)$0"
    },
    "ub": {
        "prefix": "ub",
        "body": "upper_bound($1)$0"
    },
    "len": {
        "prefix": "len",
        "body": "$1.size()$0"
    },
    "sort": {
        "prefix": "sort",
        "body": "sort($1.begin(), $1.end())$0"
    },
    "reverse": {
        "prefix": "rev",
        "body": "reverse($1.begin(), $1.end())$0"
    },
    "accumulate": {
        "prefix": "sum",
        "body": "accumulate($1.begin(), $1.end(), 0ll)$0"
    },
    "max_element": {
        "prefix": "maxe",
        "body": "*max_element($1.begin(), $1.end())"
    },
    "min_element": {
        "prefix": "mine",
        "body": "*min_element($1.begin(), $1.end())"
    },
    "prefix_sum": {
        "prefix": "prfx",
        "body": [
            "partial_sum($1.begin(), $1.end(), $2.begin())$0"
        ]
    },
    "first": {
        "prefix": "fi",
        "body": "first"
    },
    "second": {
        "prefix": "se",
        "body": "second"
    },
    "random": {
        "prefix": "random",
        "body": [
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "#define uid(a, b) uniform_int_distribution<long long>(a, b)(rng)"
        ]
    },
    "for": {
        "prefix": "for",
        "body": [
            "for (int $1 = $2; $1 < $3; $1${4:++})$0"
        ]
    },
    "ford": {
        "prefix": "ford",
        "body": [
            "for (int $1 = $2; $1 > $3; $1${4:--})$0"
        ]
    },
    "fore": {
        "prefix": "fore",
        "body": [
            "for (auto &$1 : $2)$0"
        ]
    },
    "forv": {
        "prefix": "forv",
        "body": [
            "for (auto $1 : $2)$0"
        ]
    },
    "unquie_elements": {
        "prefix": "unq",
        "body": [
            "sort($1.begin(), $1.end());",
            "$1.erase(unique($1.begin(), $1.end()), $1.end());",
            "$1.shrink_to_fit();"
        ]
    },
    "YES": {
        "prefix": "yes",
        "body": [
            "\"YES\""
        ]
    },
    "NO": {
        "prefix": "no",
        "body": [
            "\"NO\""
        ]
    },
    "get_order": {
        "prefix": "getor",
        "body": [
            "vector<int> $1($2);",
            "iota($1.begin(), $1.end(), $3);",
            "sort($1.begin(), $1.end(), [&](int i, int j) {",
            "   $4",
            "});$0"
        ]
    },
    "mappos": {
        "prefix": "mappos",
        "body": [
            "map<$1, int> $2;",
            "for (int $3 = 0; $3 < $4; $3++) {",
            "   $2[$5[$3]] = $3;",
            "}"
        ]
    },
    "counter": {
        "prefix": "counter",
        "body": [
            "map<$1, int> $2;",
            "for (int $3 = 0; $3 < $4; $3++) {",
            "   ++$2[$5[$3]];",
            "}"
        ]
    },
    "to_set": {
        "prefix": "toset",
        "body": [
            "set<$1> $2;",
            "for (int $3 = 0; $3 < $4; $3++) {",
            "   $2.insert($5[$3]);",
            "}"
        ]
    },
    "to_multiset": {
        "prefix": "tomset",
        "body": [
            "multiset<$1> $2;",
            "for (int $3 = 0; $3 < $4; $3++) {",
            "   $2.insert($5[$3]);",
            "}"
        ]
    },
    "lambda": {
        "prefix": "lambda",
        "body": [
            "auto $1 = [&]($2) -> $3 {",
            "   $4",
            "};"
        ]
    },
    "set_max": {
        "prefix": "stmx",
        "body": [
            "$1 = max($1, $2)$0"
        ]
    },
    "set_min": {
        "prefix": "stmn",
        "body": [
            "$1 = min($1, $2)$0"
        ]
    },
    "better_floor_ceil": {
        "prefix": "floce",
        "body": [
            "template <typename T, typename U>",
            "T ceil(T x, U y) { return (x > 0 ? (x + y - 1) / y : x / y); }",
            "template <typename T, typename U>",
            "T floor(T x, U y) { return (x > 0 ? x / y : (x - y + 1) / y); }"
        ]
    },
    "popcnt_int": {
        "prefix": "popcnt",
        "body": [
            "__builtin_popcount($1)"
        ]
    },
    "popcnt_long_long": {
        "prefix": "popcntll",
        "body": [
            "__builtin_popcountll($1)"
        ]
    },
    "fenwick_tree": {
        "prefix": "fenw",
        "body": [
            "struct FenwickTree {",
            "    vector<int> bit;",
            "    int n;",
            "    FenwickTree(int n) {",
            "        this->n = n;",
            "        bit.resize(n, 0);",
            "    }",
            "    FenwickTree(vector<int> const &a) : FenwickTree(a.size()) {",
            "        for (size_t i = 0; i < a.size(); i++)",
            "            add(i, a[i]);",
            "    }",
            "    int query(int r) {",
            "        int ret = 0;",
            "        for (; r >= 0; r = (r & (r + 1)) - 1)",
            "            ret += bit[r];",
            "        return ret;",
            "    }",
            "    int query(int l, int r) { return query(r) - query(l - 1); }",
            "    void add(int idx, int delta) {",
            "        for (; idx < n; idx = idx | (idx + 1))",
            "            bit[idx] += delta;",
            "    }",
            "};"
        ]
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "struct dsu {",
            "  vector<int> parent, size;",
            "  dsu(int n) {",
            "    parent.resize(n);",
            "    size.resize(n);",
            "  }",
            "  void makeset(int v) {",
            "    parent[v] = v;",
            "    size[v] = 1;",
            "  }",
            "  bool combine(int a, int b) {",
            "    a = find(a), b = find(b);",
            "    if (a == b)",
            "      return false;",
            "    if (size[a] < size[b])",
            "      swap(a, b);",
            "    parent[b] = a, size[a] += size[b];",
            "    return true;",
            "  };",
            "  int find(int v) {",
            "    if (v == parent[v])",
            "      return v;",
            "    return parent[v] = find(parent[v]);",
            "  }",
            "};"
        ]
    },
    "segment_tree": {
        "prefix": "segt",
        "body": [
            "template <typename T, typename F> struct segt {",
            "  vector<T> t;",
            "  int N;",
            "  T DF;",
            "  F combine;",
            "  segt(int n, T df, F fn) : N(n), DF(df), t(2 * n + 10), combine(fn) {",
            "    for (auto &i : t)",
            "      i = DF;",
            "  }",
            "  segt(const vector<T> &array, T df, F fn) : segt(array.size(), df, fn) {",
            "    for (int i = 0; i < N; i++)",
            "      t[i + N] = array[i];",
            "    for (int i = N - 1; i > 0; --i)",
            "      t[i] = combine(t[i << 1], t[i << 1 | 1]);",
            "  }",
            "  void set(int p, T v) {",
            "    for (t[p += N] = v; p >>= 1;)",
            "      t[p] = combine(t[p << 1], t[p << 1 | 1]);",
            "  }",
            "  T get(int l, int r) {",
            "    ++r;",
            "    T resl = DF, resr = DF;",
            "    for (l += N, r += N; l < r; l >>= 1, r >>= 1) {",
            "      if (l & 1)",
            "        resl = combine(resl, t[l++]);",
            "      if (r & 1)",
            "        resr = combine(t[--r], resr);",
            "    }",
            "    return combine(resl, resr);",
            "  }",
            "};"
        ]
    },
    "DynamicModInt": {
        "prefix": "dmint",
        "body": [
            "$0namespace dmint {",
            "constexpr long long safe_mod(long long x, long long m) {",
            "  x %= m;",
            "  if (x < 0)",
            "    x += m;",
            "  return x;",
            "}",
            "struct barrett {",
            "  unsigned int _m;",
            "  unsigned long long im;",
            "  explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "  unsigned int umod() const { return _m; }",
            "  unsigned int mul(unsigned int a, unsigned int b) const {",
            "    unsigned long long z = a;",
            "    z *= b;",
            "    unsigned long long x = (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "    unsigned long long y = x * _m;",
            "    return (unsigned int)(z - y + (z < y ? _m : 0));",
            "  }",
            "};",
            "constexpr long long pow_mod_constexpr(long long x, long long n, int m) {",
            "  if (m == 1)",
            "    return 0;",
            "  unsigned int _m = (unsigned int)(m);",
            "  unsigned long long r = 1;",
            "  unsigned long long y = safe_mod(x, m);",
            "  while (n) {",
            "    if (n & 1)",
            "      r = (r * y) % _m;",
            "    y = (y * y) % _m;",
            "    n >>= 1;",
            "  }",
            "  return r;",
            "}",
            "constexpr bool is_prime_constexpr(int n) {",
            "  if (n <= 1)",
            "    return false;",
            "  if (n == 2 || n == 7 || n == 61)",
            "    return true;",
            "  if (n % 2 == 0)",
            "    return false;",
            "  long long d = n - 1;",
            "  while (d % 2 == 0)",
            "    d /= 2;",
            "  constexpr long long bases[3] = {2, 7, 61};",
            "  for (long long a : bases) {",
            "    long long t = d;",
            "    long long y = pow_mod_constexpr(a, t, n);",
            "    while (t != n - 1 && y != 1 && y != n - 1) {",
            "      y = y * y % n;",
            "      t <<= 1;",
            "    }",
            "    if (y != n - 1 && t % 2 == 0) {",
            "      return false;",
            "    }",
            "  }",
            "  return true;",
            "}",
            "template <int n> constexpr bool is_prime = is_prime_constexpr(n);",
            "constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "  a = safe_mod(a, b);",
            "  if (a == 0)",
            "    return {b, 0};",
            "  long long s = b, t = a;",
            "  long long m0 = 0, m1 = 1;",
            "  while (t) {",
            "    long long u = s / t;",
            "    s -= t * u;",
            "    m0 -= m1 * u;",
            "    auto tmp = s;",
            "    s = t;",
            "    t = tmp;",
            "    tmp = m0;",
            "    m0 = m1;",
            "    m1 = tmp;",
            "  }",
            "  if (m0 < 0)",
            "    m0 += b / s;",
            "  return {s, m0};",
            "}",
            "template <class T>",
            "using is_signed_int128 = typename std::conditional<std::is_same<T, __int128_t>::value ||",
            "                                                       std::is_same<T, __int128>::value,",
            "                                                   std::true_type, std::false_type>::type;",
            "template <class T>",
            "using is_unsigned_int128 = typename std::conditional<std::is_same<T, __uint128_t>::value ||",
            "                                                         std::is_same<T, unsigned __int128>::value,",
            "                                                     std::true_type, std::false_type>::type;",
            "template <class T>",
            "using make_unsigned_int128 =",
            "    typename std::conditional<std::is_same<T, __int128_t>::value, __uint128_t, unsigned __int128>;",
            "template <class T>",
            "using is_integral =",
            "    typename std::conditional<std::is_integral<T>::value || is_signed_int128<T>::value ||",
            "                                  is_unsigned_int128<T>::value,",
            "                              std::true_type, std::false_type>::type;",
            "template <class T>",
            "using is_signed_int =",
            "    typename std::conditional<(is_integral<T>::value && std::is_signed<T>::value) ||",
            "                                  is_signed_int128<T>::value,",
            "                              std::true_type, std::false_type>::type;",
            "template <class T>",
            "using is_unsigned_int =",
            "    typename std::conditional<(is_integral<T>::value && std::is_unsigned<T>::value) ||",
            "                                  is_unsigned_int128<T>::value,",
            "                              std::true_type, std::false_type>::type;",
            "template <class T>",
            "using to_unsigned = typename std::conditional<",
            "    is_signed_int128<T>::value, make_unsigned_int128<T>,",
            "    typename std::conditional<std::is_signed<T>::value, std::make_unsigned<T>,",
            "                              std::common_type<T>>::type>::type;",
            "template <class T> using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "template <class T> using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "template <class T> using to_unsigned_t = typename to_unsigned<T>::type;",
            "struct modint_base {};",
            "struct static_modint_base : modint_base {};",
            "template <class T> using is_modint = std::is_base_of<modint_base, T>;",
            "template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;",
            "template <int m, std::enable_if_t<(1 <= m)> * = nullptr> struct static_modint : static_modint_base {",
            "  using mint = static_modint;",
            "public:",
            "  static constexpr int mod() { return m; }",
            "  static mint raw(int v) {",
            "    mint x;",
            "    x._v = v;",
            "    return x;",
            "  }",
            "  static_modint() : _v(0) {}",
            "  template <class T, is_signed_int_t<T> * = nullptr> static_modint(T v) {",
            "    long long x = (long long)(v % (long long)(umod()));",
            "    if (x < 0)",
            "      x += umod();",
            "    _v = (unsigned int)(x);",
            "  }",
            "  template <class T, is_unsigned_int_t<T> * = nullptr> static_modint(T v) {",
            "    _v = (unsigned int)(v % umod());",
            "  }",
            "  unsigned int val() const { return _v; }",
            "  mint &operator++() {",
            "    _v++;",
            "    if (_v == umod())",
            "      _v = 0;",
            "    return *this;",
            "  }",
            "  mint &operator--() {",
            "    if (_v == 0)",
            "      _v = umod();",
            "    _v--;",
            "    return *this;",
            "  }",
            "  mint operator++(int) {",
            "    mint result = *this;",
            "    ++*this;",
            "    return result;",
            "  }",
            "  mint operator--(int) {",
            "    mint result = *this;",
            "    --*this;",
            "    return result;",
            "  }",
            "  mint &operator+=(const mint &rhs) {",
            "    _v += rhs._v;",
            "    if (_v >= umod())",
            "      _v -= umod();",
            "    return *this;",
            "  }",
            "  mint &operator-=(const mint &rhs) {",
            "    _v -= rhs._v;",
            "    if (_v >= umod())",
            "      _v += umod();",
            "    return *this;",
            "  }",
            "  mint &operator*=(const mint &rhs) {",
            "    unsigned long long z = _v;",
            "    z *= rhs._v;",
            "    _v = (unsigned int)(z % umod());",
            "    return *this;",
            "  }",
            "  mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "  mint operator+() const { return *this; }",
            "  mint operator-() const { return mint() - *this; }",
            "  mint pow(long long n) const {",
            "    assert(0 <= n);",
            "    mint x = *this, r = 1;",
            "    while (n) {",
            "      if (n & 1)",
            "        r *= x;",
            "      x *= x;",
            "      n >>= 1;",
            "    }",
            "    return r;",
            "  }",
            "  mint inv() const {",
            "    if (prime) {",
            "      assert(_v);",
            "      return pow(umod() - 2);",
            "    } else {",
            "      auto eg = inv_gcd(_v, m);",
            "      assert(eg.first == 1);",
            "      return eg.second;",
            "    }",
            "  }",
            "  friend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "  friend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "  friend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "  friend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "  friend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
            "  friend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
            "private:",
            "  unsigned int _v;",
            "  static constexpr unsigned int umod() { return m; }",
            "  static constexpr bool prime = is_prime<m>;",
            "};",
            "template <int id> struct dynamic_modint : modint_base {",
            "  using mint = dynamic_modint;",
            "public:",
            "  static int mod() { return (int)(bt.umod()); }",
            "  static void set_mod(int m) {",
            "    assert(1 <= m);",
            "    bt = barrett(m);",
            "  }",
            "  static mint raw(int v) {",
            "    mint x;",
            "    x._v = v;",
            "    return x;",
            "  }",
            "  dynamic_modint() : _v(0) {}",
            "  template <class T, is_signed_int_t<T> * = nullptr> dynamic_modint(T v) {",
            "    long long x = (long long)(v % (long long)(mod()));",
            "    if (x < 0)",
            "      x += mod();",
            "    _v = (unsigned int)(x);",
            "  }",
            "  template <class T, is_unsigned_int_t<T> * = nullptr> dynamic_modint(T v) {",
            "    _v = (unsigned int)(v % mod());",
            "  }",
            "  unsigned int val() const { return _v; }",
            "  mint &operator++() {",
            "    _v++;",
            "    if (_v == umod())",
            "      _v = 0;",
            "    return *this;",
            "  }",
            "  mint &operator--() {",
            "    if (_v == 0)",
            "      _v = umod();",
            "    _v--;",
            "    return *this;",
            "  }",
            "  mint operator++(int) {",
            "    mint result = *this;",
            "    ++*this;",
            "    return result;",
            "  }",
            "  mint operator--(int) {",
            "    mint result = *this;",
            "    --*this;",
            "    return result;",
            "  }",
            "  mint &operator+=(const mint &rhs) {",
            "    _v += rhs._v;",
            "    if (_v >= umod())",
            "      _v -= umod();",
            "    return *this;",
            "  }",
            "  mint &operator-=(const mint &rhs) {",
            "    _v += mod() - rhs._v;",
            "    if (_v >= umod())",
            "      _v -= umod();",
            "    return *this;",
            "  }",
            "  mint &operator*=(const mint &rhs) {",
            "    _v = bt.mul(_v, rhs._v);",
            "    return *this;",
            "  }",
            "  mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "  mint operator+() const { return *this; }",
            "  mint operator-() const { return mint() - *this; }",
            "  mint pow(long long n) const {",
            "    assert(0 <= n);",
            "    mint x = *this, r = 1;",
            "    while (n) {",
            "      if (n & 1)",
            "        r *= x;",
            "      x *= x;",
            "      n >>= 1;",
            "    }",
            "    return r;",
            "  }",
            "  mint inv() const {",
            "    auto eg = inv_gcd(_v, mod());",
            "    assert(eg.first == 1);",
            "    return eg.second;",
            "  }",
            "  friend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "  friend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "  friend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "  friend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "  friend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
            "  friend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
            "private:",
            "  unsigned int _v;",
            "  static barrett bt;",
            "  static unsigned int umod() { return bt.umod(); }",
            "};",
            "template <int id> barrett dynamic_modint<id>::bt(998244353);",
            "};"
        ]
    },
    "lazyseg": {
        "prefix": "lazyseg",
        "body": [
            "$0namespace lazyseg {",
            "unsigned int bit_ceil(unsigned int n) {",
            "  unsigned int x = 1;",
            "  while (x < (unsigned int)(n))",
            "    x *= 2;",
            "  return x;",
            "}",
            "int countr_zero(unsigned int n) { return __builtin_ctz(n); }",
            "constexpr int countr_zero_constexpr(unsigned int n) {",
            "  int x = 0;",
            "  while (!(n & (1 << x)))",
            "    x++;",
            "  return x;",
            "}",
            "template <class S, auto op, auto e, class F, auto mapping, auto composition, auto id>",
            "struct lazy_segtree {",
            "  static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>, \"op must work as S(S, S)\");",
            "  static_assert(std::is_convertible_v<decltype(e), std::function<S()>>, \"e must work as S()\");",
            "  static_assert(std::is_convertible_v<decltype(mapping), std::function<S(F, S)>>, \"mapping must work as F(F, S)\");",
            "  static_assert(std::is_convertible_v<decltype(composition), std::function<F(F, F)>>, \"compostiion must work as F(F, F)\");",
            "  static_assert(std::is_convertible_v<decltype(id), std::function<F()>>, \"id must work as F()\");",
            "public:",
            "  lazy_segtree() : lazy_segtree(0) {}",
            "  explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}",
            "  explicit lazy_segtree(const std::vector<S> &v) : _n(int32_t(v.size())) {",
            "    size = (int)bit_ceil((unsigned int)(_n));",
            "    log = countr_zero((unsigned int)size);",
            "    d = std::vector<S>(2 * size, e());",
            "    lz = std::vector<F>(size, id());",
            "    for (int i = 0; i < _n; i++)",
            "      d[size + i] = v[i];",
            "    for (int i = size - 1; i >= 1; i--) {",
            "      update(i);",
            "    }",
            "  }",
            "  void set(int p, S x) {",
            "    assert(0 <= p && p < _n);",
            "    p += size;",
            "    for (int i = log; i >= 1; i--)",
            "      push(p >> i);",
            "    d[p] = x;",
            "    for (int i = 1; i <= log; i++)",
            "      update(p >> i);",
            "  }",
            "  S get(int p) {",
            "    assert(0 <= p && p < _n);",
            "    p += size;",
            "    for (int i = log; i >= 1; i--)",
            "      push(p >> i);",
            "    return d[p];",
            "  }",
            "  S prod(int l, int r) {",
            "    assert(0 <= l && l <= r && r <= _n);",
            "    if (l == r)",
            "      return e();",
            "    l += size;",
            "    r += size;",
            "    for (int i = log; i >= 1; i--) {",
            "      if (((l >> i) << i) != l)",
            "        push(l >> i);",
            "      if (((r >> i) << i) != r)",
            "        push((r - 1) >> i);",
            "    }",
            "    S sml = e(), smr = e();",
            "    while (l < r) {",
            "      if (l & 1)",
            "        sml = op(sml, d[l++]);",
            "      if (r & 1)",
            "        smr = op(d[--r], smr);",
            "      l >>= 1;",
            "      r >>= 1;",
            "    }",
            "    return op(sml, smr);",
            "  }",
            "  S all_prod() { return d[1]; }",
            "  void apply(int p, F f) {",
            "    assert(0 <= p && p < _n);",
            "    p += size;",
            "    for (int i = log; i >= 1; i--)",
            "      push(p >> i);",
            "    d[p] = mapping(f, d[p]);",
            "    for (int i = 1; i <= log; i++)",
            "      update(p >> i);",
            "  }",
            "  void apply(int l, int r, F f) {",
            "    assert(0 <= l && l <= r && r <= _n);",
            "    if (l == r)",
            "      return;",
            "    l += size;",
            "    r += size;",
            "    for (int i = log; i >= 1; i--) {",
            "      if (((l >> i) << i) != l)",
            "        push(l >> i);",
            "      if (((r >> i) << i) != r)",
            "        push((r - 1) >> i);",
            "    }",
            "    {",
            "      int l2 = l, r2 = r;",
            "      while (l < r) {",
            "        if (l & 1)",
            "          all_apply(l++, f);",
            "        if (r & 1)",
            "          all_apply(--r, f);",
            "        l >>= 1;",
            "        r >>= 1;",
            "      }",
            "      l = l2;",
            "      r = r2;",
            "    }",
            "    for (int i = 1; i <= log; i++) {",
            "      if (((l >> i) << i) != l)",
            "        update(l >> i);",
            "      if (((r >> i) << i) != r)",
            "        update((r - 1) >> i);",
            "    }",
            "  }",
            "  template <bool (*g)(S)> int max_right(int l) {",
            "    return max_right(l, [](S x) { return g(x); });",
            "  }",
            "  template <class G> int max_right(int l, G g) {",
            "    assert(0 <= l && l <= _n);",
            "    assert(g(e()));",
            "    if (l == _n)",
            "      return _n;",
            "    l += size;",
            "    for (int i = log; i >= 1; i--)",
            "      push(l >> i);",
            "    S sm = e();",
            "    do {",
            "      while (l % 2 == 0)",
            "        l >>= 1;",
            "      if (!g(op(sm, d[l]))) {",
            "        while (l < size) {",
            "          push(l);",
            "          l = (2 * l);",
            "          if (g(op(sm, d[l]))) {",
            "            sm = op(sm, d[l]);",
            "            l++;",
            "          }",
            "        }",
            "        return l - size;",
            "      }",
            "      sm = op(sm, d[l]);",
            "      l++;",
            "    } while ((l & -l) != l);",
            "    return _n;",
            "  }",
            "  template <bool (*g)(S)> int min_left(int r) {",
            "    return min_left(r, [](S x) { return g(x); });",
            "  }",
            "  template <class G> int min_left(int r, G g) {",
            "    assert(0 <= r && r <= _n);",
            "    assert(g(e()));",
            "    if (r == 0)",
            "      return 0;",
            "    r += size;",
            "    for (int i = log; i >= 1; i--)",
            "      push((r - 1) >> i);",
            "    S sm = e();",
            "    do {",
            "      r--;",
            "      while (r > 1 && (r % 2))",
            "        r >>= 1;",
            "      if (!g(op(d[r], sm))) {",
            "        while (r < size) {",
            "          push(r);",
            "          r = (2 * r + 1);",
            "          if (g(op(d[r], sm))) {",
            "            sm = op(d[r], sm);",
            "            r--;",
            "          }",
            "        }",
            "        return r + 1 - size;",
            "      }",
            "      sm = op(d[r], sm);",
            "    } while ((r & -r) != r);",
            "    return 0;",
            "  }",
            "private:",
            "  int _n, size, log;",
            "  std::vector<S> d;",
            "  std::vector<F> lz;",
            "  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
            "  void all_apply(int k, F f) {",
            "    d[k] = mapping(f, d[k]);",
            "    if (k < size)",
            "      lz[k] = composition(f, lz[k]);",
            "  }",
            "  void push(int k) {",
            "    all_apply(2 * k, lz[k]);",
            "    all_apply(2 * k + 1, lz[k]);",
            "    lz[k] = id();",
            "  }",
            "};",
            "};"
        ]
    },
    "z_function": {
        "prefix": "zfunction",
        "body": [
            "vector<int> z_function(string s) {",
            "  int n = s.size();",
            "  vector<int> z(n);",
            "  int l = 0, r = 0;",
            "  for (int i = 1; i < n; i++) {",
            "    if (i < r) {",
            "      z[i] = min(r - i, z[i - l]);",
            "    }",
            "    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
            "      z[i]++;",
            "    }",
            "    if (i + z[i] > r) {",
            "      l = i;",
            "      r = i + z[i];",
            "    }",
            "  }",
            "  return z;",
            "}"
        ]
    },
    "hashing": {
        "prefix": "hashing",
        "body": [
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "#define uid(a, b) uniform_int_distribution<long long>(a, b)(rng)",
            "struct random_hashv {",
            "  const long long md = 1000000000000000003;",
            "  __int128_t base;",
            "  vector<__int128_t> powers, inv_powers;",
            "  random_hashv(int max_len) : powers(max_len), inv_powers(max_len), base(uid(1, md - 1)) {",
            "    for (int i = 0; i < max_len; i++)",
            "      powers[i] = i ? (powers[i - 1] * base) % md : 1;",
            "    for (int i = 0; i < max_len; i++) {",
            "      __int128_t a = powers[i], b = md, u = 1, v = 0;",
            "      while (b) {",
            "        __int128_t t = a / b;",
            "        a -= t * b, swap(a, b);",
            "        u -= t * v, swap(u, v);",
            "      }",
            "      inv_powers[i] = (u < 0 ? u + md : u);",
            "    }",
            "  }",
            "  void add(long long &hash, int i, long long multiplier) {",
            "    hash = (hash + (multiplier * powers[i]) % md) % md;",
            "  }",
            "  void remove(long long &hash, int i, long long multiplier) {",
            "    hash = (hash + md - ((multiplier * powers[i]) % md)) % md;",
            "  }",
            "  long long get_hash(const string &s, char default_char) {",
            "    long long hash = 0;",
            "    int sz = s.size();",
            "    for (int i = 0; i < sz; i++)",
            "      add(hash, i, (long long)s[i] - default_char);",
            "    return hash;",
            "  }",
            "};"
        ]
    },
    "combinations": {
        "prefix": "combi",
        "body": [
            "template <typename MI, const int SZ> struct combi {",
            "  static constexpr int M = SZ;",
            "  array<MI, M> fact, invfact;",
            "  constexpr combi() {",
            "    fact[0] = invfact[0] = 1;",
            "    for (int i = 1; i < M; i++)",
            "      fact[i] = fact[i - 1] * i;",
            "    invfact[M - 1] = fact[M - 1].inv();",
            "    for (int i = M - 2; i; i--)",
            "      invfact[i] = invfact[i + 1] * (i + 1);",
            "  }",
            "  inline MI C(int a, int b) {",
            "    if (a < 0 || b < 0 || a < b)",
            "      return 0;",
            "    return fact[a] * invfact[b] * invfact[a - b];",
            "  }",
            "};"
        ]
    },
    "number_theory": {
        "prefix": "numb",
        "body": [
            "template <const int SZ> struct numb {",
            "  static constexpr int M = SZ;",
            "  int pc = 0;",
            "  array<int, M> primes, lpf;",
            "  bitset<M> isPrime;",
            "  constexpr numb() {",
            "    for (int i = 2; i < M; ++i) {",
            "      if (!lpf[i]) {",
            "        primes[pc++] = i;",
            "        lpf[i] = i;",
            "        isPrime[i] = 1;",
            "      }",
            "      for (int j = 0; j < pc && 1LL * i * primes[j] < M && primes[j] <= lpf[i]; j++)",
            "        lpf[i * primes[j]] = primes[j];",
            "    }",
            "  }",
            "  pair<int, array<pair<int, int>, 30>> pfact(int V) {",
            "    array<pair<int, int>, 30> ret;",
            "    int sz = 0;",
            "    for (int p = lpf[V], cnt = 0; V > 1; p = lpf[V], cnt = 0) {",
            "      while (V % p == 0)",
            "        V /= p, ++cnt;",
            "      ret[sz++] = {p, cnt};",
            "    }",
            "    return {sz, ret};",
            "  }",
            "};"
        ]
    },
    "fast_power": {
        "prefix": "fpow",
        "body": [
            "long long fpow(long long x, long long n) {",
            "    long long result = 1;",
            "    for (; n > 0; n >>= 1, x *= x) {",
            "        if (n & 1)",
            "            result *= x;",
            "    }",
            "    return result;",
            "}"
        ]
    },
    "trie": {
        "prefix": "trie",
        "body": [
            "struct trie {",
            "  struct node {",
            "    int flag;",
            "    vector<int> nxt;",
            "    node(int entities) : flag(0), nxt(entities, -1) {}",
            "  };",
            "  vector<node> data;",
            "  int mxi, entities;",
            "  trie(int entities) : entities(entities), mxi(0) {",
            "    data.push_back(node(entities));",
            "  }",
            "  void add(auto element);",
            "  auto get(auto element);",
            "};"
        ]
    },
    "lca": {
        "prefix": "lca",
        "body": [
            "struct lowca {",
            "    int n, l, timer;",
            "    vector<vector<int>> adj;",
            "    vector<int> tin, tout;",
            "    vector<vector<int>> up;",
            "    vector<int> depth;",
            "    lowca(int n_, const vector<vector<int>> &g, int root_ = 0)",
            "        : n(n_), tin(n), tout(n), up(n), depth(n) {",
            "        adj = g;",
            "        preprocess(root_);",
            "    };",
            "  private:",
            "    void dfs(int v, int p, int dpt) {",
            "        depth[v] = dpt;",
            "        tin[v] = ++timer;",
            "        up[v][0] = p;",
            "        for (int i = 1; i <= l; ++i)",
            "            up[v][i] = up[up[v][i - 1]][i - 1];",
            "        for (int u : adj[v]) {",
            "            if (u != p)",
            "                dfs(u, v, dpt + 1);",
            "        }",
            "        tout[v] = ++timer;",
            "    }",
            "    void preprocess(int root) {",
            "        tin.resize(n);",
            "        tout.resize(n);",
            "        timer = 0;",
            "        l = ceil(log2(n));",
            "        up.assign(n, vector<int>(l + 1));",
            "        dfs(root, root, 0);",
            "    }",
            "  public:",
            "    bool is_ancestor(int u, int v) {",
            "        return tin[u] <= tin[v] && tout[u] >= tout[v];",
            "    }",
            "    int lca(int u, int v) {",
            "        if (is_ancestor(u, v))",
            "            return u;",
            "        if (is_ancestor(v, u))",
            "            return v;",
            "        for (int i = l; i >= 0; --i) {",
            "            if (!is_ancestor(up[u][i], v))",
            "                u = up[u][i];",
            "        }",
            "        return up[u][0];",
            "    }",
            "    int kth_ancestor(int u, int k) {",
            "        while (k) {",
            "            int t = __builtin_ctz(k);",
            "            u = up[u][t], k ^= 1 << t;",
            "        }",
            "        return u;",
            "    }",
            "    int kth_node_on_path(int u, int v, int k) {",
            "        int lc = lca(u, v);",
            "        int tn = depth[u] + depth[v] - 2 * depth[lc] + 1;",
            "        if (depth[u] - depth[lc] + 1 >= k)",
            "            return kth_ancestor(u, k - 1);",
            "        return kth_ancestor(v, tn - k);",
            "    }",
            "    int total_nodes_on_path(int u, int v) {",
            "        int lc = lca(u, v);",
            "        return depth[u] + depth[v] - 2 * depth[lc] + 1;",
            "    }",
            "    int distance(int u, int v) { return total_nodes_on_path(u, v) - 1; }",
            "};"
        ]
    },
    "Static Mint": {
        "prefix": "mint",
        "body": [
            "template <const int T> struct ModInt {",
            "    const static int mod = T;",
            "    int x;",
            "    int val() { return x; }",
            "    ModInt(int x = 0) : x(x % mod) {}",
            "    ModInt(long long x) : x(int(x % mod)) {}",
            "    ModInt operator+(const ModInt &a) const {",
            "        int x0 = x + a.x;",
            "        return ModInt(x0 < mod ? x0 : x0 - mod);",
            "    }",
            "    ModInt operator-(const ModInt &a) const {",
            "        int x0 = x - a.x;",
            "        return ModInt(x0 < 0 ? x0 + mod : x0);",
            "    }",
            "    ModInt operator*(const ModInt &a) const {",
            "        return ModInt(1ll * x * a.x % mod);",
            "    }",
            "    ModInt operator/(const ModInt &a) const { return *this * a.inv(); }",
            "    void operator+=(const ModInt &a) {",
            "        x += a.x;",
            "        if (x >= mod)",
            "            x -= mod;",
            "    }",
            "    void operator-=(const ModInt &a) {",
            "        x -= a.x;",
            "        if (x < 0)",
            "            x += mod;",
            "    }",
            "    void operator*=(const ModInt &a) { x = 1LL * x * a.x % mod; }",
            "    void operator/=(const ModInt &a) { *this = *this / a; }",
            "    ModInt pow(int64_t n) const {",
            "        ModInt res(1), mul(x);",
            "        while (n) {",
            "            if (n & 1)",
            "                res *= mul;",
            "            mul *= mul;",
            "            n >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "    ModInt inv() const {",
            "        int a = x, b = mod, u = 1, v = 0;",
            "        while (b) {",
            "            int t = a / b;",
            "            a -= t * b;",
            "            swap(a, b);",
            "            u -= t * v;",
            "            swap(u, v);",
            "        }",
            "        if (u < 0)",
            "            u += mod;",
            "        return u;",
            "    }",
            "};"
        ]
    },
    "LazyJiangly": {
        "prefix": "lazyjiangly",
        "body": [
            "template <class Info, class Tag> struct LazySegmentTree {",
            "    int n;",
            "    std::vector<Info> info;",
            "    std::vector<Tag> tag;",
            "    LazySegmentTree() : n(0) {}",
            "    LazySegmentTree(int n_, Info v_ = Info()) { init(n_, v_); }",
            "    template <class T> LazySegmentTree(std::vector<T> init_) { init(init_); }",
            "    void init(int n_, Info v_ = Info()) { init(std::vector(n_, v_)); }",
            "    template <class T> void init(std::vector<T> init_) {",
            "        n = init_.size();",
            "        info.assign(4 << std::__lg(n), Info());",
            "        tag.assign(4 << std::__lg(n), Tag());",
            "        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
            "            if (r - l == 1) {",
            "                info[p] = init_[l];",
            "                return;",
            "            }",
            "            int m = (l + r) / 2;",
            "            build(2 * p, l, m);",
            "            build(2 * p + 1, m, r);",
            "            pull(p);",
            "        };",
            "        build(1, 0, n);",
            "    }",
            "    void pull(int p) { info[p] = info[2 * p] + info[2 * p + 1]; }",
            "    void apply(int p, const Tag &v) {",
            "        info[p].apply(v);",
            "        tag[p].apply(v);",
            "    }",
            "    void push(int p) {",
            "        apply(2 * p, tag[p]);",
            "        apply(2 * p + 1, tag[p]);",
            "        tag[p] = Tag();",
            "    }",
            "    void modify(int p, int l, int r, int x, const Info &v) {",
            "        if (r - l == 1) {",
            "            info[p] = v;",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        if (x < m) {",
            "            modify(2 * p, l, m, x, v);",
            "        } else {",
            "            modify(2 * p + 1, m, r, x, v);",
            "        }",
            "        pull(p);",
            "    }",
            "    void modify(int p, const Info &v) { modify(1, 0, n, p, v); }",
            "    Info rangeQuery(int p, int l, int r, int x, int y) {",
            "        if (l >= y || r <= x) {",
            "            return Info();",
            "        }",
            "        if (l >= x && r <= y) {",
            "            return info[p];",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        return rangeQuery(2 * p, l, m, x, y) +",
            "               rangeQuery(2 * p + 1, m, r, x, y);",
            "    }",
            "    Info rangeQuery(int l, int r) { return rangeQuery(1, 0, n, l, r); }",
            "    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {",
            "        if (l >= y || r <= x) {",
            "            return;",
            "        }",
            "        if (l >= x && r <= y) {",
            "            apply(p, v);",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        rangeApply(2 * p, l, m, x, y, v);",
            "        rangeApply(2 * p + 1, m, r, x, y, v);",
            "        pull(p);",
            "    }",
            "    void rangeApply(int l, int r, const Tag &v) {",
            "        return rangeApply(1, 0, n, l, r, v);",
            "    }",
            "    template <class F>",
            "    int findFirst(int p, int l, int r, int x, int y, F pred) {",
            "        if (l >= y || r <= x || !pred(info[p])) {",
            "            return -1;",
            "        }",
            "        if (r - l == 1) {",
            "            return l;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        int res = findFirst(2 * p, l, m, x, y, pred);",
            "        if (res == -1) {",
            "            res = findFirst(2 * p + 1, m, r, x, y, pred);",
            "        }",
            "        return res;",
            "    }",
            "    template <class F> int findFirst(int l, int r, F pred) {",
            "        return findFirst(1, 0, n, l, r, pred);",
            "    }",
            "    template <class F> int findLast(int p, int l, int r, int x, int y, F pred) {",
            "        if (l >= y || r <= x || !pred(info[p])) {",
            "            return -1;",
            "        }",
            "        if (r - l == 1) {",
            "            return l;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        int res = findLast(2 * p + 1, m, r, x, y, pred);",
            "        if (res == -1) {",
            "            res = findLast(2 * p, l, m, x, y, pred);",
            "        }",
            "        return res;",
            "    }",
            "    template <class F> int findLast(int l, int r, F pred) {",
            "        return findLast(1, 0, n, l, r, pred);",
            "    }",
            "};",
            "struct Tag {",
            "    i64 add = 0;",
            "    void apply(const Tag &t) {",
            "        add += t.add;",
            "    }",
            "};",
            "struct Info {",
            "    i64 min = inf;",
            "    i64 max = -inf;",
            "    void apply(const Tag &t) {",
            "        min += t.add;",
            "        max += t.add;",
            "    }",
            "};"
        ]
    }
}
