{
    "manacher_palindromes": {
        "prefix": "manacher_palindromes",
        "body": [
            "template <typename T> struct manacher {",
            "  public:",
            "    manacher(const vector<T> &s, T ex1, T ex2, T ex3) {",
            "        vector<T> t;",
            "        for (auto c : s) {",
            "            t.push_back(ex1);",
            "            t.push_back(c);",
            "        }",
            "        t.push_back(ex1);",
            "        res = manacher_odd(t, ex2, ex3);",
            "    }",
            "    int get_odd(int i) { return res[2 * i + 1] / 2; }",
            "    int get_even(int i) { return (res[2 * i] - 1) / 2; }",
            "  private:",
            "    vector<T> res;",
            "    vector<T> manacher_odd(vector<T> s, T ex1, T ex2) {",
            "        int n = s.size();",
            "        s.emplace(s.begin(), ex1);",
            "        s.push_back(ex2);",
            "        vector<int> p(n + 2);",
            "        int l = 1, r = 1;",
            "        for (int i = 1; i <= n; i++) {",
            "            p[i] = max(0, min(r - i, p[l + (r - i)]));",
            "            while (s[i - p[i]] == s[i + p[i]]) {",
            "                ++p[i];",
            "            }",
            "            if (i + p[i] > r) {",
            "                l = i - p[i], r = i + p[i];",
            "            }",
            "        }",
            "        return vector<T>(begin(p) + 1, end(p) - 1);",
            "    }",
            "};"
        ]
    },
    "policy_based_ds": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "template <typename T> using ost = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;"
        ]
    },
    "random": {
        "prefix": "random",
        "body": [
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "#define uid(a, b) uniform_int_distribution<long long>(a, b)(rng)"
        ]
    },
    "unquie_elements": {
        "prefix": "unq",
        "body": [
            "sort($1.begin(), $1.end());",
            "$1.erase(unique($1.begin(), $1.end()), $1.end());",
            "$1.shrink_to_fit();"
        ]
    },
    "better_floor_ceil": {
        "prefix": "floce",
        "body": [
            "template <typename T, typename U>",
            "T ceil(T x, U y) { return (x > 0 ? (x + y - 1) / y : x / y); }",
            "template <typename T, typename U>",
            "T floor(T x, U y) { return (x > 0 ? x / y : (x - y + 1) / y); }"
        ]
    },
    "popcnt_int": {
        "prefix": "popcnt",
        "body": [
            "__builtin_popcount($1)"
        ]
    },
    "popcnt_long_long": {
        "prefix": "popcntll",
        "body": [
            "__builtin_popcountll($1)"
        ]
    },
    "fenwick_tree": {
        "prefix": "fenw",
        "body": [
            "template <typename T, const int N> struct FenwickTree {",
            "    T bit[N];",
            "    int n;",
            "    void set(int idx, T val, bool add = false) {",
            "        for (; idx < n; idx = idx | (idx + 1))",
            "            bit[idx] = (add ? bit[idx] : 0) + val;",
            "    }",
            "    T query(int r) {",
            "        T ret = 0;",
            "        for (; r >= 0; r = (r & (r + 1)) - 1)",
            "            ret += bit[r];",
            "        return ret;",
            "    }",
            "};"
        ]
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "struct dsu {",
            "    vector<int> parent, size;",
            "    dsu(int n) {",
            "        parent.assign(n, -1);",
            "        size.assign(n, 0);",
            "    }",
            "    void makeset(int v) {",
            "        parent[v] = v;",
            "        size[v] = 1;",
            "    }",
            "    bool combine(int a, int b) {",
            "        a = find(a), b = find(b);",
            "        if (a == b)",
            "            return false;",
            "        if (size[a] < size[b])",
            "            swap(a, b);",
            "        parent[b] = a, size[a] += size[b];",
            "        return true;",
            "    };",
            "    int find(int v) {",
            "        if (v == parent[v])",
            "            return v;",
            "        return parent[v] = find(parent[v]);",
            "    }",
            "};"
        ]
    },
    "segment_tree": {
        "prefix": "segt",
        "body": [
            "template <typename T> struct segt {",
            "    int n;",
            "    T df;",
            "    vector<T> t;",
            "    function<T(T, T)> combine;",
            "    segt(int N, int DF, function<T(T, T)> f) : combine(f), n(N), df(DF) {",
            "        t.assign(2 * n + 10, df);",
            "    }",
            "    void set(int p, T v) {",
            "        for (t[p += n] = v; p >>= 1;)",
            "            t[p] = combine(t[p << 1], t[p << 1 | 1]);",
            "    }",
            "    T get(int l, int r) {",
            "        if (l >= r)",
            "            return df;",
            "        T resl = df, resr = df;",
            "        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
            "            if (l & 1)",
            "                resl = combine(resl, t[l++]);",
            "            if (r & 1)",
            "                resr = combine(t[--r], resr);",
            "        }",
            "        return combine(resl, resr);",
            "    }",
            "};"
        ]
    },
    "ModInt": {
        "prefix": "mint",
        "body": [
            "using i64 = int64_t;",
            "using u32 = uint32_t;",
            "using u64 = uint64_t;",
            "using u128 = __uint128_t; // available on 64-bit targets",
            "",
            "template <typename T, auto M> struct Mod {",
            "  using V = conditional_t<sizeof(T) <= 4, u64, u128>;",
            "  static V inv(V x, V m) { return x > 1 ? m - inv(m % x, x) * m / x : 1; }",
            "  make_unsigned_t<T> x;",
            "  Mod() : x(0) {}",
            "  Mod(auto y) : x(y % M) { x >= M ? x += M : x; }",
            "  operator T() const { return x; }",
            "  Mod operator-() const { return Mod() -= *this; }",
            "  Mod operator+(auto rhs) const { return Mod(*this) += rhs; }",
            "  Mod operator-(auto rhs) const { return Mod(*this) -= rhs; }",
            "  Mod operator*(auto rhs) const { return Mod(*this) *= rhs; }",
            "  Mod operator/(auto rhs) const { return Mod(*this) /= rhs; }",
            "  Mod &operator+=(Mod rhs) { return (x += rhs.x) >= M ? x -= M : x, *this; }",
            "  Mod &operator-=(Mod rhs) { return (x -= rhs.x) >= M ? x += M : x, *this; }",
            "  Mod &operator*=(Mod rhs) { return x = x * V(rhs.x) % M, *this; }",
            "  Mod &operator/=(Mod rhs) { return x = x * inv(rhs.x, M) % M, *this; }",
            "  Mod pow(auto y) const { // O(log y) | 0^(-inf,0] -> 1",
            "    Mod ans(1), base(*this);",
            "    for (auto e = y < 0 ? ~y + u128(1) : +y; e; e >>= 1, base *= base) {",
            "      e & 1 ? ans *= base : ans;",
            "    }",
            "    return y < 0 ? Mod(1) /= ans : ans;",
            "  }",
            "};",
            "",
            "using mint = Mod<int, 998244353>;"
        ]
    },
    "DynamicModInt": {
        "prefix": "dmint",
        "body": [
            "$0namespace dmint {",
            "constexpr long long safe_mod(long long x, long long m) {",
            "  x %= m;",
            "  if (x < 0)",
            "    x += m;",
            "  return x;",
            "}",
            "struct barrett {",
            "  unsigned int _m;",
            "  unsigned long long im;",
            "  explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "  unsigned int umod() const { return _m; }",
            "  unsigned int mul(unsigned int a, unsigned int b) const {",
            "    unsigned long long z = a;",
            "    z *= b;",
            "    unsigned long long x = (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "    unsigned long long y = x * _m;",
            "    return (unsigned int)(z - y + (z < y ? _m : 0));",
            "  }",
            "};",
            "constexpr long long pow_mod_constexpr(long long x, long long n, int m) {",
            "  if (m == 1)",
            "    return 0;",
            "  unsigned int _m = (unsigned int)(m);",
            "  unsigned long long r = 1;",
            "  unsigned long long y = safe_mod(x, m);",
            "  while (n) {",
            "    if (n & 1)",
            "      r = (r * y) % _m;",
            "    y = (y * y) % _m;",
            "    n >>= 1;",
            "  }",
            "  return r;",
            "}",
            "constexpr bool is_prime_constexpr(int n) {",
            "  if (n <= 1)",
            "    return false;",
            "  if (n == 2 || n == 7 || n == 61)",
            "    return true;",
            "  if (n % 2 == 0)",
            "    return false;",
            "  long long d = n - 1;",
            "  while (d % 2 == 0)",
            "    d /= 2;",
            "  constexpr long long bases[3] = {2, 7, 61};",
            "  for (long long a : bases) {",
            "    long long t = d;",
            "    long long y = pow_mod_constexpr(a, t, n);",
            "    while (t != n - 1 && y != 1 && y != n - 1) {",
            "      y = y * y % n;",
            "      t <<= 1;",
            "    }",
            "    if (y != n - 1 && t % 2 == 0) {",
            "      return false;",
            "    }",
            "  }",
            "  return true;",
            "}",
            "template <int n> constexpr bool is_prime = is_prime_constexpr(n);",
            "constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "  a = safe_mod(a, b);",
            "  if (a == 0)",
            "    return {b, 0};",
            "  long long s = b, t = a;",
            "  long long m0 = 0, m1 = 1;",
            "  while (t) {",
            "    long long u = s / t;",
            "    s -= t * u;",
            "    m0 -= m1 * u;",
            "    auto tmp = s;",
            "    s = t;",
            "    t = tmp;",
            "    tmp = m0;",
            "    m0 = m1;",
            "    m1 = tmp;",
            "  }",
            "  if (m0 < 0)",
            "    m0 += b / s;",
            "  return {s, m0};",
            "}",
            "template <class T>",
            "using is_signed_int128 = typename std::conditional<std::is_same<T, __int128_t>::value ||",
            "                                                       std::is_same<T, __int128>::value,",
            "                                                   std::true_type, std::false_type>::type;",
            "template <class T>",
            "using is_unsigned_int128 = typename std::conditional<std::is_same<T, __uint128_t>::value ||",
            "                                                         std::is_same<T, unsigned __int128>::value,",
            "                                                     std::true_type, std::false_type>::type;",
            "template <class T>",
            "using make_unsigned_int128 =",
            "    typename std::conditional<std::is_same<T, __int128_t>::value, __uint128_t, unsigned __int128>;",
            "template <class T>",
            "using is_integral =",
            "    typename std::conditional<std::is_integral<T>::value || is_signed_int128<T>::value ||",
            "                                  is_unsigned_int128<T>::value,",
            "                              std::true_type, std::false_type>::type;",
            "template <class T>",
            "using is_signed_int =",
            "    typename std::conditional<(is_integral<T>::value && std::is_signed<T>::value) ||",
            "                                  is_signed_int128<T>::value,",
            "                              std::true_type, std::false_type>::type;",
            "template <class T>",
            "using is_unsigned_int =",
            "    typename std::conditional<(is_integral<T>::value && std::is_unsigned<T>::value) ||",
            "                                  is_unsigned_int128<T>::value,",
            "                              std::true_type, std::false_type>::type;",
            "template <class T>",
            "using to_unsigned = typename std::conditional<",
            "    is_signed_int128<T>::value, make_unsigned_int128<T>,",
            "    typename std::conditional<std::is_signed<T>::value, std::make_unsigned<T>,",
            "                              std::common_type<T>>::type>::type;",
            "template <class T> using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "template <class T> using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "template <class T> using to_unsigned_t = typename to_unsigned<T>::type;",
            "struct modint_base {};",
            "struct static_modint_base : modint_base {};",
            "template <class T> using is_modint = std::is_base_of<modint_base, T>;",
            "template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;",
            "template <int m, std::enable_if_t<(1 <= m)> * = nullptr> struct static_modint : static_modint_base {",
            "  using mint = static_modint;",
            "public:",
            "  static constexpr int mod() { return m; }",
            "  static mint raw(int v) {",
            "    mint x;",
            "    x._v = v;",
            "    return x;",
            "  }",
            "  static_modint() : _v(0) {}",
            "  template <class T, is_signed_int_t<T> * = nullptr> static_modint(T v) {",
            "    long long x = (long long)(v % (long long)(umod()));",
            "    if (x < 0)",
            "      x += umod();",
            "    _v = (unsigned int)(x);",
            "  }",
            "  template <class T, is_unsigned_int_t<T> * = nullptr> static_modint(T v) {",
            "    _v = (unsigned int)(v % umod());",
            "  }",
            "  unsigned int val() const { return _v; }",
            "  mint &operator++() {",
            "    _v++;",
            "    if (_v == umod())",
            "      _v = 0;",
            "    return *this;",
            "  }",
            "  mint &operator--() {",
            "    if (_v == 0)",
            "      _v = umod();",
            "    _v--;",
            "    return *this;",
            "  }",
            "  mint operator++(int) {",
            "    mint result = *this;",
            "    ++*this;",
            "    return result;",
            "  }",
            "  mint operator--(int) {",
            "    mint result = *this;",
            "    --*this;",
            "    return result;",
            "  }",
            "  mint &operator+=(const mint &rhs) {",
            "    _v += rhs._v;",
            "    if (_v >= umod())",
            "      _v -= umod();",
            "    return *this;",
            "  }",
            "  mint &operator-=(const mint &rhs) {",
            "    _v -= rhs._v;",
            "    if (_v >= umod())",
            "      _v += umod();",
            "    return *this;",
            "  }",
            "  mint &operator*=(const mint &rhs) {",
            "    unsigned long long z = _v;",
            "    z *= rhs._v;",
            "    _v = (unsigned int)(z % umod());",
            "    return *this;",
            "  }",
            "  mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "  mint operator+() const { return *this; }",
            "  mint operator-() const { return mint() - *this; }",
            "  mint pow(long long n) const {",
            "    assert(0 <= n);",
            "    mint x = *this, r = 1;",
            "    while (n) {",
            "      if (n & 1)",
            "        r *= x;",
            "      x *= x;",
            "      n >>= 1;",
            "    }",
            "    return r;",
            "  }",
            "  mint inv() const {",
            "    if (prime) {",
            "      assert(_v);",
            "      return pow(umod() - 2);",
            "    } else {",
            "      auto eg = inv_gcd(_v, m);",
            "      assert(eg.first == 1);",
            "      return eg.second;",
            "    }",
            "  }",
            "  friend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "  friend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "  friend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "  friend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "  friend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
            "  friend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
            "private:",
            "  unsigned int _v;",
            "  static constexpr unsigned int umod() { return m; }",
            "  static constexpr bool prime = is_prime<m>;",
            "};",
            "template <int id> struct dynamic_modint : modint_base {",
            "  using mint = dynamic_modint;",
            "public:",
            "  static int mod() { return (int)(bt.umod()); }",
            "  static void set_mod(int m) {",
            "    assert(1 <= m);",
            "    bt = barrett(m);",
            "  }",
            "  static mint raw(int v) {",
            "    mint x;",
            "    x._v = v;",
            "    return x;",
            "  }",
            "  dynamic_modint() : _v(0) {}",
            "  template <class T, is_signed_int_t<T> * = nullptr> dynamic_modint(T v) {",
            "    long long x = (long long)(v % (long long)(mod()));",
            "    if (x < 0)",
            "      x += mod();",
            "    _v = (unsigned int)(x);",
            "  }",
            "  template <class T, is_unsigned_int_t<T> * = nullptr> dynamic_modint(T v) {",
            "    _v = (unsigned int)(v % mod());",
            "  }",
            "  unsigned int val() const { return _v; }",
            "  mint &operator++() {",
            "    _v++;",
            "    if (_v == umod())",
            "      _v = 0;",
            "    return *this;",
            "  }",
            "  mint &operator--() {",
            "    if (_v == 0)",
            "      _v = umod();",
            "    _v--;",
            "    return *this;",
            "  }",
            "  mint operator++(int) {",
            "    mint result = *this;",
            "    ++*this;",
            "    return result;",
            "  }",
            "  mint operator--(int) {",
            "    mint result = *this;",
            "    --*this;",
            "    return result;",
            "  }",
            "  mint &operator+=(const mint &rhs) {",
            "    _v += rhs._v;",
            "    if (_v >= umod())",
            "      _v -= umod();",
            "    return *this;",
            "  }",
            "  mint &operator-=(const mint &rhs) {",
            "    _v += mod() - rhs._v;",
            "    if (_v >= umod())",
            "      _v -= umod();",
            "    return *this;",
            "  }",
            "  mint &operator*=(const mint &rhs) {",
            "    _v = bt.mul(_v, rhs._v);",
            "    return *this;",
            "  }",
            "  mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "  mint operator+() const { return *this; }",
            "  mint operator-() const { return mint() - *this; }",
            "  mint pow(long long n) const {",
            "    assert(0 <= n);",
            "    mint x = *this, r = 1;",
            "    while (n) {",
            "      if (n & 1)",
            "        r *= x;",
            "      x *= x;",
            "      n >>= 1;",
            "    }",
            "    return r;",
            "  }",
            "  mint inv() const {",
            "    auto eg = inv_gcd(_v, mod());",
            "    assert(eg.first == 1);",
            "    return eg.second;",
            "  }",
            "  friend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "  friend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "  friend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "  friend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "  friend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
            "  friend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
            "private:",
            "  unsigned int _v;",
            "  static barrett bt;",
            "  static unsigned int umod() { return bt.umod(); }",
            "};",
            "template <int id> barrett dynamic_modint<id>::bt(998244353);",
            "};",
            "const int md = 1e9 + 7;",
            "using mint = dmint::static_modint<md>;",
            "#ifdef LOCAL",
            "void __print(mint x) { std::cerr << x.val(); }",
            "#endif"
        ]
    },
    "lazyseg": {
        "prefix": "lazyseg",
        "body": [
            "$0namespace lazyseg {",
            "unsigned int bit_ceil(unsigned int n) {",
            "  unsigned int x = 1;",
            "  while (x < (unsigned int)(n))",
            "    x *= 2;",
            "  return x;",
            "}",
            "int countr_zero(unsigned int n) { return __builtin_ctz(n); }",
            "constexpr int countr_zero_constexpr(unsigned int n) {",
            "  int x = 0;",
            "  while (!(n & (1 << x)))",
            "    x++;",
            "  return x;",
            "}",
            "template <class S, auto op, auto e, class F, auto mapping, auto composition, auto id>",
            "struct lazy_segtree {",
            "  static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>, \"op must work as S(S, S)\");",
            "  static_assert(std::is_convertible_v<decltype(e), std::function<S()>>, \"e must work as S()\");",
            "  static_assert(std::is_convertible_v<decltype(mapping), std::function<S(F, S)>>, \"mapping must work as F(F, S)\");",
            "  static_assert(std::is_convertible_v<decltype(composition), std::function<F(F, F)>>, \"compostiion must work as F(F, F)\");",
            "  static_assert(std::is_convertible_v<decltype(id), std::function<F()>>, \"id must work as F()\");",
            "public:",
            "  lazy_segtree() : lazy_segtree(0) {}",
            "  explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}",
            "  explicit lazy_segtree(const std::vector<S> &v) : _n(int32_t(v.size())) {",
            "    size = (int)bit_ceil((unsigned int)(_n));",
            "    log = countr_zero((unsigned int)size);",
            "    d = std::vector<S>(2 * size, e());",
            "    lz = std::vector<F>(size, id());",
            "    for (int i = 0; i < _n; i++)",
            "      d[size + i] = v[i];",
            "    for (int i = size - 1; i >= 1; i--) {",
            "      update(i);",
            "    }",
            "  }",
            "  void set(int p, S x) {",
            "    assert(0 <= p && p < _n);",
            "    p += size;",
            "    for (int i = log; i >= 1; i--)",
            "      push(p >> i);",
            "    d[p] = x;",
            "    for (int i = 1; i <= log; i++)",
            "      update(p >> i);",
            "  }",
            "  S get(int p) {",
            "    assert(0 <= p && p < _n);",
            "    p += size;",
            "    for (int i = log; i >= 1; i--)",
            "      push(p >> i);",
            "    return d[p];",
            "  }",
            "  S prod(int l, int r) {",
            "    assert(0 <= l && l <= r && r <= _n);",
            "    if (l == r)",
            "      return e();",
            "    l += size;",
            "    r += size;",
            "    for (int i = log; i >= 1; i--) {",
            "      if (((l >> i) << i) != l)",
            "        push(l >> i);",
            "      if (((r >> i) << i) != r)",
            "        push((r - 1) >> i);",
            "    }",
            "    S sml = e(), smr = e();",
            "    while (l < r) {",
            "      if (l & 1)",
            "        sml = op(sml, d[l++]);",
            "      if (r & 1)",
            "        smr = op(d[--r], smr);",
            "      l >>= 1;",
            "      r >>= 1;",
            "    }",
            "    return op(sml, smr);",
            "  }",
            "  S all_prod() { return d[1]; }",
            "  void apply(int p, F f) {",
            "    assert(0 <= p && p < _n);",
            "    p += size;",
            "    for (int i = log; i >= 1; i--)",
            "      push(p >> i);",
            "    d[p] = mapping(f, d[p]);",
            "    for (int i = 1; i <= log; i++)",
            "      update(p >> i);",
            "  }",
            "  void apply(int l, int r, F f) {",
            "    assert(0 <= l && l <= r && r <= _n);",
            "    if (l == r)",
            "      return;",
            "    l += size;",
            "    r += size;",
            "    for (int i = log; i >= 1; i--) {",
            "      if (((l >> i) << i) != l)",
            "        push(l >> i);",
            "      if (((r >> i) << i) != r)",
            "        push((r - 1) >> i);",
            "    }",
            "    {",
            "      int l2 = l, r2 = r;",
            "      while (l < r) {",
            "        if (l & 1)",
            "          all_apply(l++, f);",
            "        if (r & 1)",
            "          all_apply(--r, f);",
            "        l >>= 1;",
            "        r >>= 1;",
            "      }",
            "      l = l2;",
            "      r = r2;",
            "    }",
            "    for (int i = 1; i <= log; i++) {",
            "      if (((l >> i) << i) != l)",
            "        update(l >> i);",
            "      if (((r >> i) << i) != r)",
            "        update((r - 1) >> i);",
            "    }",
            "  }",
            "  template <bool (*g)(S)> int max_right(int l) {",
            "    return max_right(l, [](S x) { return g(x); });",
            "  }",
            "  template <class G> int max_right(int l, G g) {",
            "    assert(0 <= l && l <= _n);",
            "    assert(g(e()));",
            "    if (l == _n)",
            "      return _n;",
            "    l += size;",
            "    for (int i = log; i >= 1; i--)",
            "      push(l >> i);",
            "    S sm = e();",
            "    do {",
            "      while (l % 2 == 0)",
            "        l >>= 1;",
            "      if (!g(op(sm, d[l]))) {",
            "        while (l < size) {",
            "          push(l);",
            "          l = (2 * l);",
            "          if (g(op(sm, d[l]))) {",
            "            sm = op(sm, d[l]);",
            "            l++;",
            "          }",
            "        }",
            "        return l - size;",
            "      }",
            "      sm = op(sm, d[l]);",
            "      l++;",
            "    } while ((l & -l) != l);",
            "    return _n;",
            "  }",
            "  template <bool (*g)(S)> int min_left(int r) {",
            "    return min_left(r, [](S x) { return g(x); });",
            "  }",
            "  template <class G> int min_left(int r, G g) {",
            "    assert(0 <= r && r <= _n);",
            "    assert(g(e()));",
            "    if (r == 0)",
            "      return 0;",
            "    r += size;",
            "    for (int i = log; i >= 1; i--)",
            "      push((r - 1) >> i);",
            "    S sm = e();",
            "    do {",
            "      r--;",
            "      while (r > 1 && (r % 2))",
            "        r >>= 1;",
            "      if (!g(op(d[r], sm))) {",
            "        while (r < size) {",
            "          push(r);",
            "          r = (2 * r + 1);",
            "          if (g(op(d[r], sm))) {",
            "            sm = op(d[r], sm);",
            "            r--;",
            "          }",
            "        }",
            "        return r + 1 - size;",
            "      }",
            "      sm = op(d[r], sm);",
            "    } while ((r & -r) != r);",
            "    return 0;",
            "  }",
            "private:",
            "  int _n, size, log;",
            "  std::vector<S> d;",
            "  std::vector<F> lz;",
            "  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
            "  void all_apply(int k, F f) {",
            "    d[k] = mapping(f, d[k]);",
            "    if (k < size)",
            "      lz[k] = composition(f, lz[k]);",
            "  }",
            "  void push(int k) {",
            "    all_apply(2 * k, lz[k]);",
            "    all_apply(2 * k + 1, lz[k]);",
            "    lz[k] = id();",
            "  }",
            "};",
            "};"
        ]
    },
    "z_function": {
        "prefix": "zfunction",
        "body": [
            "vector<int> z_function(string s) {",
            "  int n = s.size();",
            "  vector<int> z(n);",
            "  int l = 0, r = 0;",
            "  for (int i = 1; i < n; i++) {",
            "    if (i < r) {",
            "      z[i] = min(r - i, z[i - l]);",
            "    }",
            "    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
            "      z[i]++;",
            "    }",
            "    if (i + z[i] > r) {",
            "      l = i;",
            "      r = i + z[i];",
            "    }",
            "  }",
            "  return z;",
            "}"
        ]
    },
    "hashing": {
        "prefix": "hashing",
        "body": [
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "#define uid(a, b) uniform_int_distribution<long long>(a, b)(rng)",
            "struct random_hashv {",
            "  const long long md = 1000000000000000003;",
            "  __int128_t base;",
            "  vector<__int128_t> powers, inv_powers;",
            "  random_hashv(int max_len) : powers(max_len), inv_powers(max_len), base(uid(1, md - 1)) {",
            "    for (int i = 0; i < max_len; i++)",
            "      powers[i] = i ? (powers[i - 1] * base) % md : 1;",
            "    for (int i = 0; i < max_len; i++) {",
            "      __int128_t a = powers[i], b = md, u = 1, v = 0;",
            "      while (b) {",
            "        __int128_t t = a / b;",
            "        a -= t * b, swap(a, b);",
            "        u -= t * v, swap(u, v);",
            "      }",
            "      inv_powers[i] = (u < 0 ? u + md : u);",
            "    }",
            "  }",
            "  void add(long long &hash, int i, long long multiplier) {",
            "    hash = (hash + (multiplier * powers[i]) % md) % md;",
            "  }",
            "  void remove(long long &hash, int i, long long multiplier) {",
            "    hash = (hash + md - ((multiplier * powers[i]) % md)) % md;",
            "  }",
            "  long long get_hash(const string &s, char default_char) {",
            "    long long hash = 0;",
            "    int sz = s.size();",
            "    for (int i = 0; i < sz; i++)",
            "      add(hash, i, (long long)s[i] - default_char);",
            "    return hash;",
            "  }",
            "};",
            "",
            "struct hashed {",
            "    int n;",
            "    int base_val;",
            "    vector<long long> prfx;",
            "    random_hashv hs;",
            "    template <typename T>",
            "    hashed(T container, int def)",
            "        : n(container.size()), prfx(n + 1), hs(n), base_val(def) {",
            "        for (int i = 0; i < n; ++i) {",
            "            hs.add(prfx[i + 1], i, container[i] - base_val);",
            "            prfx[i + 1] = (prfx[i + 1] + prfx[i]) % hs.md;",
            "        }",
            "    }",
            "    long long get(int l, int r) {",
            "        long long val = (prfx[r + 1] - prfx[l] + hs.md) % hs.md;",
            "        return (val * hs.inv_powers[l]) % hs.md;",
            "    }",
            "    bool cmp(int i, int j, int sz) {",
            "        assert(i + sz - 1 < n && j + sz - 1 < n);",
            "        return get(i, i + sz - 1) == get(j, j + sz - 1);",
            "    }",
            "};"
        ]
    },
    "combinations": {
        "prefix": "combi",
        "body": [
            "template <typename MI, const int SZ> struct combi {",
            "  static constexpr int M = SZ;",
            "  array<MI, M> fact, invfact;",
            "  constexpr combi() {",
            "    fact[0] = invfact[0] = 1;",
            "    for (int i = 1; i < M; i++)",
            "      fact[i] = fact[i - 1] * i;",
            "    invfact[M - 1] = fact[M - 1].inv();",
            "    for (int i = M - 2; i; i--)",
            "      invfact[i] = invfact[i + 1] * (i + 1);",
            "  }",
            "  inline MI C(int a, int b) {",
            "    if (a < 0 || b < 0 || a < b)",
            "      return 0;",
            "    return fact[a] * invfact[b] * invfact[a - b];",
            "  }",
            "};"
        ]
    },
    "number_theory": {
        "prefix": "numb",
        "body": [
            "template <const int SZ> struct numb {",
            "    static constexpr int M = SZ;",
            "    int pc = 0;",
            "    array<int, M> primes, lpf;",
            "    bitset<M> isPrime;",
            "    constexpr numb() {",
            "        for (int i = 2; i < M; ++i) {",
            "            if (!lpf[i]) {",
            "                primes[pc++] = i;",
            "                lpf[i] = i;",
            "                isPrime[i] = 1;",
            "            }",
            "            for (int j = 0;",
            "                 j < pc && 1LL * i * primes[j] < M && primes[j] <= lpf[i]; j++)",
            "                lpf[i * primes[j]] = primes[j];",
            "        }",
            "    }",
            "    pair<int, array<int, 30>> pfact(int V) {",
            "        array<int, 30> ret;",
            "        int sz = 0;",
            "        for (int p = lpf[V], cnt = 0; V > 1; p = lpf[V], cnt = 0) {",
            "            while (V % p == 0)",
            "                V /= p;",
            "            ret[sz++] = p;",
            "        }",
            "        return {sz, ret};",
            "    }",
            "    pair<int, array<pair<int, int>, 30>> pfact_with_frq(int V) {",
            "        array<pair<int, int>, 30> ret;",
            "        int sz = 0;",
            "        for (int p = lpf[V], cnt = 0; V > 1; p = lpf[V], cnt = 0) {",
            "            while (V % p == 0)",
            "                V /= p, ++cnt;",
            "            ret[sz++] = {p, cnt};",
            "        }",
            "        return {sz, ret};",
            "    }",
            "};"
        ]
    },
    "fast_power": {
        "prefix": "fpow",
        "body": [
            "long long fpow(long long x, long long n) {",
            "    long long result = 1;",
            "    for (; n > 0; n >>= 1, x *= x) {",
            "        if (n & 1)",
            "            result *= x;",
            "    }",
            "    return result;",
            "}"
        ]
    },
    "fast_power_mod": {
        "prefix": "fpowMod",
        "body": [
            "#define int int64_t",
            "int fpm(int a, int b, int m) {",
            "        int res = 1;",
            "        for (; b > 0; b >>= 1, a = (a * a) % m) {",
            "                if (b & 1) {",
            "                        res = (res * a) % m;",
            "                }",
            "        }",
            "        return res;",
            "}"
        ]
    },
    "lca": {
        "prefix": "lca",
        "body": [
            "struct lowca {",
            "    int n, l, timer;",
            "    vector<vector<int>> adj;",
            "    vector<int> tin, tout;",
            "    vector<vector<int>> up;",
            "    vector<int> depth;",
            "    lowca(int n_, const vector<vector<int>> &g, int root_ = 0)",
            "        : n(n_), tin(n), tout(n), up(n), depth(n) {",
            "        adj = g;",
            "        preprocess(root_);",
            "    };",
            "  private:",
            "    void dfs(int v, int p, int dpt) {",
            "        depth[v] = dpt;",
            "        tin[v] = ++timer;",
            "        up[v][0] = p;",
            "        for (int i = 1; i <= l; ++i)",
            "            up[v][i] = up[up[v][i - 1]][i - 1];",
            "        for (int u : adj[v]) {",
            "            if (u != p)",
            "                dfs(u, v, dpt + 1);",
            "        }",
            "        tout[v] = ++timer;",
            "    }",
            "    void preprocess(int root) {",
            "        tin.resize(n);",
            "        tout.resize(n);",
            "        timer = 0;",
            "        l = ceil(log2(n));",
            "        up.assign(n, vector<int>(l + 1));",
            "        dfs(root, root, 0);",
            "    }",
            "  public:",
            "    bool is_ancestor(int u, int v) {",
            "        return tin[u] <= tin[v] && tout[u] >= tout[v];",
            "    }",
            "    int lca(int u, int v) {",
            "        if (is_ancestor(u, v))",
            "            return u;",
            "        if (is_ancestor(v, u))",
            "            return v;",
            "        for (int i = l; i >= 0; --i) {",
            "            if (!is_ancestor(up[u][i], v))",
            "                u = up[u][i];",
            "        }",
            "        return up[u][0];",
            "    }",
            "    int kth_ancestor(int u, int k) {",
            "        while (k) {",
            "            int t = __builtin_ctz(k);",
            "            u = up[u][t], k ^= 1 << t;",
            "        }",
            "        return u;",
            "    }",
            "    int kth_node_on_path(int u, int v, int k) {",
            "        int lc = lca(u, v);",
            "        int tn = depth[u] + depth[v] - 2 * depth[lc] + 1;",
            "        if (depth[u] - depth[lc] + 1 >= k)",
            "            return kth_ancestor(u, k - 1);",
            "        return kth_ancestor(v, tn - k);",
            "    }",
            "    int total_nodes_on_path(int u, int v) {",
            "        int lc = lca(u, v);",
            "        return depth[u] + depth[v] - 2 * depth[lc] + 1;",
            "    }",
            "    int distance(int u, int v) { return total_nodes_on_path(u, v) - 1; }",
            "};"
        ]
    },
    "custom_hash": {
        "prefix": "custom_hash",
        "body": [
            "struct custom_hash {",
            "  static uint64_t splitmix64(uint64_t x) {",
            "    // http://xorshift.di.unimi.it/splitmix64.c",
            "    x += 0x9e3779b97f4a7c15;",
            "    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "    return x ^ (x >> 31);",
            "  }",
            "  size_t operator()(uint64_t x) const {",
            "    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "    return splitmix64(x + FIXED_RANDOM);",
            "  }",
            "};"
        ]
    },
    "zalgorithm": {
        "prefix": "zalgo",
        "body": [
            "template <class T> vector<int> z_algorithm(const vector<T> &s) {",
            "  int n = s.size();",
            "  if (n == 0)",
            "    return {};",
            "  vector<int> z(n);",
            "  z[0] = 0;",
            "  for (int i = 1, j = 0; i < n; i++) {",
            "    int &k = z[i];",
            "    k = (j + z[j] <= i) ? 0 : min(j + z[j] - i, z[i - j]);",
            "    while (i + k < n && s[k] == s[i + k])",
            "      k++;",
            "    if (j + z[j] < i + z[i])",
            "      j = i;",
            "  }",
            "  z[0] = n;",
            "  return z;",
            "}"
        ]
    },
    "sparse_table": {
        "prefix": "sparsetable",
        "body": [
            "template <class T>",
            "struct SparseTable {",
            "  vector<vector<T>> table;",
            "  int K;",
            "  T combine(T l, T r) {",
            "    return gcd(l, r);",
            "  }",
            "  SparseTable(int n, int k, vector<T> &arr) : K(k), table(n, vector<T>(k)) {",
            "    int i;",
            "    for (i = 0; i < n; i++) {",
            "      table[i][0] = arr[i];",
            "    }",
            "    int j;",
            "    for (j = 1; j <= k; j++) {",
            "      for (i = 0; i <= n - (1 << j); i++) {",
            "        table[i][j] = combine(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);",
            "      }",
            "    }",
            "  };",
            "  T get(int l, int r) {",
            "    r--;",
            "    int i;",
            "    T res = 0;",
            "    for (i = K; i >= 0; i--) {",
            "      if (l + (1 << i) - 1 <= r) {",
            "        res = combine(res, table[l][i]);",
            "        l = l + (1 << i);",
            "      }",
            "    }",
            "    return res;",
            "  }",
            "};"
        ]
    }
}
