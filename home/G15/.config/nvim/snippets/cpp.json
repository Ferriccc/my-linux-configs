{
  "policy_based_ds": {
    "prefix": "pbds",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "template <typename T> using ost = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;"
    ]
  },
  "vec": {
    "prefix": "vec",
    "body": "vector<$1> $0"
  },
  "pair": {
    "prefix": "pair",
    "body": "pair<$1, $1> $0"
  },
  "pq": {
    "prefix": "pq",
    "body": "priority_queue<$1> $0"
  },
  "mpq": {
    "prefix": "mpq",
    "body": "priority_queue<$1, vector<$1>, greater<$1>> $0"
  },
  "new_line": {
    "prefix": "nl",
    "body": "'\\n'"
  },
  "space": {
    "prefix": "sp",
    "body": "' '"
  },
  "ll": {
    "prefix": "ll",
    "body": "long long"
  },
  "int128": {
    "prefix": "i128",
    "body": "__int128"
  },
  "pb": {
    "prefix": "pb",
    "body": "push_back($1)$0"
  },
  "eb": {
    "prefix": "eb",
    "body": "emplace_back($1)$0"
  },
  "bg": {
    "prefix": "beg",
    "body": "begin()"
  },
  "ed": {
    "prefix": "end",
    "body": "end()"
  },
  "all": {
    "prefix": "all",
    "body": "$1.begin(), $1.end()$0"
  },
  "lb": {
    "prefix": "lb",
    "body": "lower_bound($1)$0"
  },
  "ub": {
    "prefix": "ub",
    "body": "upper_bound($1)$0"
  },
  "len": {
    "prefix": "len",
    "body": "$1.size()$0"
  },
  "sort": {
    "prefix": "sort",
    "body": "sort($1.begin(), $1.end())$0"
  },
  "reverse": {
    "prefix": "rev",
    "body": "reverse($1.begin(), $1.end())$0"
  },
  "accumulate": {
    "prefix": "sum",
    "body": "accumulate($1.begin(), $1.end(), 0ll)$0"
  },
  "max_element": {
    "prefix": "maxe",
    "body": "*max_element($1.begin(), $1.end())"
  },
  "min_element": {
    "prefix": "mine",
    "body": "*min_element($1.begin(), $1.end())"
  },
  "prefix_sum": {
    "prefix": "prfx",
    "body": [
      "partial_sum($1.begin(), $1.end(), $2.begin())$0"
    ]
  },
  "first": {
    "prefix": "fi",
    "body": "first"
  },
  "second": {
    "prefix": "se",
    "body": "second"
  },
  "random": {
    "prefix": "random",
    "body": [
      "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "#define uid(a, b) uniform_int_distribution<long long>(a, b)(rng)"
    ]
  },
  "for": {
    "prefix": "for",
    "body": [
      "for (int $1 = $2; $1 < $3; ${4:++$1})$0"
    ]
  },
  "ford": {
    "prefix": "ford",
    "body": [
      "for (int $1 = $2; $1 > $3; ${4:--$1})$0"
    ]
  },
  "fore": {
    "prefix": "fore",
    "body": [
      "for (auto &$1 : $2)$0"
    ]
  },
  "forv": {
    "prefix": "forv",
    "body": [
      "for (auto $1 : $2)$0"
    ]
  },
  "unquie_elements": {
    "prefix": "unq",
    "body": [
      "sort($1.begin(), $1.end());",
      "$1.erase(unique($1.begin(), $1.end()), $1.end());",
      "$1.shrink_to_fit();"
    ]
  },
  "YES": {
    "prefix": "yes",
    "body": [
      "\"YES\""
    ]
  },
  "NO": {
    "prefix": "no",
    "body": [
      "\"NO\""
    ]
  },
  "get_order": {
    "prefix": "getor",
    "body": [
      "vector<int> $1($2);",
      "iota($1.begin(), $1.end(), $3);",
      "sort($1.begin(), $1.end(), [&](int i, int j) {",
      "   $4",
      "});$0"
    ]
  },
  "mappos": {
    "prefix": "mappos",
    "body": [
      "map<$1, int> $2;",
      "for (int $3 = 0; $3 < $4; $3++) {",
      "   $2[$5[$3]] = $3;",
      "}"
    ]
  },
  "counter": {
    "prefix": "counter",
    "body": [
      "map<$1, int> $2;",
      "for (int $3 = 0; $3 < $4; $3++) {",
      "   ++$2[$5[$3]];",
      "}"
    ]
  },
  "to_set": {
    "prefix": "toset",
    "body": [
      "set<$1> $2;",
      "for (int $3 = 0; $3 < $4; $3++) {",
      "   $2.insert($5[$3]);",
      "}"
    ]
  },
  "to_multiset": {
    "prefix": "tomset",
    "body": [
      "multiset<$1> $2;",
      "for (int $3 = 0; $3 < $4; $3++) {",
      "   $2.insert($5[$3]);",
      "}"
    ]
  },
  "lambda": {
    "prefix": "lambda",
    "body": [
      "auto $1 = [&]($2) -> $3 {",
      "   $4",
      "};"
    ]
  },
  "set_max": {
    "prefix": "stmx",
    "body": [
      "$1 = max($1, $2)$0"
    ]
  },
  "set_min": {
    "prefix": "stmn",
    "body": [
      "$1 = min($1, $2)$0"
    ]
  },
  "better_floor_ceil": {
    "prefix": "floce",
    "body": [
      "template <typename T, typename U>",
      "T ceil(T x, U y) { return (x > 0 ? (x + y - 1) / y : x / y); }",
      "template <typename T, typename U>",
      "T floor(T x, U y) { return (x > 0 ? x / y : (x - y + 1) / y); }"
    ]
  },
  "popcnt_int": {
    "prefix": "popcnt",
    "body": [
      "__builtin_popcount($1)"
    ]
  },
  "popcnt_long_long": {
    "prefix": "popcntll",
    "body": [
      "__builtin_popcountll($1)"
    ]
  },
  "fenwick_tree": {
    "prefix": "fenw",
    "body": [
      "template <typename T> struct FenwickTree {",
      "    vector<T> bit;",
      "    int n;",
      "    FenwickTree(int n) {",
      "        this->n = n;",
      "        bit.resize(n, 0);",
      "    }",
      "    FenwickTree(vector<T> const &a) : FenwickTree(a.size()) {",
      "        for (size_t i = 0; i < a.size(); i++)",
      "            add(i, a[i]);",
      "    }",
      "    T query(int r) {",
      "        T ret = 0;",
      "        for (; r >= 0; r = (r & (r + 1)) - 1)",
      "            ret += bit[r];",
      "        return ret;",
      "    }",
      "    T query(int l, int r) { return query(r) - query(l - 1); }",
      "    void set(int idx, T val) {",
      "        for (; idx < n; idx = idx | (idx + 1))",
      "            bit[idx] = val;",
      "    }",
      "};"
    ]
  },
  "dsu": {
    "prefix": "dsu",
    "body": [
      "struct dsu {",
      "  vector<int> parent, size;",
      "  dsu(int n) {",
      "    parent.resize(n);",
      "    size.resize(n);",
      "  }",
      "  void makeset(int v) {",
      "    parent[v] = v;",
      "    size[v] = 1;",
      "  }",
      "  bool combine(int a, int b) {",
      "    a = find(a), b = find(b);",
      "    if (a == b)",
      "      return false;",
      "    if (size[a] < size[b])",
      "      swap(a, b);",
      "    parent[b] = a, size[a] += size[b];",
      "    return true;",
      "  };",
      "  int find(int v) {",
      "    if (v == parent[v])",
      "      return v;",
      "    return parent[v] = find(parent[v]);",
      "  }",
      "};"
    ]
  },
  "segment_tree": {
    "prefix": "segt",
    "body": [
      "template <typename T, typename F> struct segt {",
      "  int N;",
      "  T DF;",
      "  vector<T> t;",
      "  F combine;",
      "  segt(int n, T df, F fn) : N(n + 1), DF(df), t(2 * N + 10), combine(fn) {",
      "    for (auto &i : t)",
      "      i = DF;",
      "  }",
      "  segt(const vector<T> &array, T df, F fn) : segt(array.size(), df, fn) {",
      "    for (int i = 0; i < N; i++)",
      "      t[i + N] = array[i];",
      "    for (int i = N - 1; i > 0; --i)",
      "      t[i] = combine(t[i << 1], t[i << 1 | 1]);",
      "  }",
      "  void set(int p, T v) {",
      "    for (t[p += N] = v; p >>= 1;)",
      "      t[p] = combine(t[p << 1], t[p << 1 | 1]);",
      "  }",
      "  void add(int p, T v) { set(p, get(p, p + 1) + v); }",
      "  T get(int l, int r) {",
      "    if (l >= r) {",
      "      return DF;",
      "    }",
      "    T resl = DF, resr = DF;",
      "    for (l += N, r += N; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1)",
      "        resl = combine(resl, t[l++]);",
      "      if (r & 1)",
      "        resr = combine(t[--r], resr);",
      "    }",
      "    return combine(resl, resr);",
      "  }",
      "};"
    ]
  },
  "DynamicModInt": {
    "prefix": "dmint",
    "body": [
      "$0namespace dmint {",
      "constexpr long long safe_mod(long long x, long long m) {",
      "  x %= m;",
      "  if (x < 0)",
      "    x += m;",
      "  return x;",
      "}",
      "struct barrett {",
      "  unsigned int _m;",
      "  unsigned long long im;",
      "  explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
      "  unsigned int umod() const { return _m; }",
      "  unsigned int mul(unsigned int a, unsigned int b) const {",
      "    unsigned long long z = a;",
      "    z *= b;",
      "    unsigned long long x = (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
      "    unsigned long long y = x * _m;",
      "    return (unsigned int)(z - y + (z < y ? _m : 0));",
      "  }",
      "};",
      "constexpr long long pow_mod_constexpr(long long x, long long n, int m) {",
      "  if (m == 1)",
      "    return 0;",
      "  unsigned int _m = (unsigned int)(m);",
      "  unsigned long long r = 1;",
      "  unsigned long long y = safe_mod(x, m);",
      "  while (n) {",
      "    if (n & 1)",
      "      r = (r * y) % _m;",
      "    y = (y * y) % _m;",
      "    n >>= 1;",
      "  }",
      "  return r;",
      "}",
      "constexpr bool is_prime_constexpr(int n) {",
      "  if (n <= 1)",
      "    return false;",
      "  if (n == 2 || n == 7 || n == 61)",
      "    return true;",
      "  if (n % 2 == 0)",
      "    return false;",
      "  long long d = n - 1;",
      "  while (d % 2 == 0)",
      "    d /= 2;",
      "  constexpr long long bases[3] = {2, 7, 61};",
      "  for (long long a : bases) {",
      "    long long t = d;",
      "    long long y = pow_mod_constexpr(a, t, n);",
      "    while (t != n - 1 && y != 1 && y != n - 1) {",
      "      y = y * y % n;",
      "      t <<= 1;",
      "    }",
      "    if (y != n - 1 && t % 2 == 0) {",
      "      return false;",
      "    }",
      "  }",
      "  return true;",
      "}",
      "template <int n> constexpr bool is_prime = is_prime_constexpr(n);",
      "constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
      "  a = safe_mod(a, b);",
      "  if (a == 0)",
      "    return {b, 0};",
      "  long long s = b, t = a;",
      "  long long m0 = 0, m1 = 1;",
      "  while (t) {",
      "    long long u = s / t;",
      "    s -= t * u;",
      "    m0 -= m1 * u;",
      "    auto tmp = s;",
      "    s = t;",
      "    t = tmp;",
      "    tmp = m0;",
      "    m0 = m1;",
      "    m1 = tmp;",
      "  }",
      "  if (m0 < 0)",
      "    m0 += b / s;",
      "  return {s, m0};",
      "}",
      "template <class T>",
      "using is_signed_int128 = typename std::conditional<std::is_same<T, __int128_t>::value ||",
      "                                                       std::is_same<T, __int128>::value,",
      "                                                   std::true_type, std::false_type>::type;",
      "template <class T>",
      "using is_unsigned_int128 = typename std::conditional<std::is_same<T, __uint128_t>::value ||",
      "                                                         std::is_same<T, unsigned __int128>::value,",
      "                                                     std::true_type, std::false_type>::type;",
      "template <class T>",
      "using make_unsigned_int128 =",
      "    typename std::conditional<std::is_same<T, __int128_t>::value, __uint128_t, unsigned __int128>;",
      "template <class T>",
      "using is_integral =",
      "    typename std::conditional<std::is_integral<T>::value || is_signed_int128<T>::value ||",
      "                                  is_unsigned_int128<T>::value,",
      "                              std::true_type, std::false_type>::type;",
      "template <class T>",
      "using is_signed_int =",
      "    typename std::conditional<(is_integral<T>::value && std::is_signed<T>::value) ||",
      "                                  is_signed_int128<T>::value,",
      "                              std::true_type, std::false_type>::type;",
      "template <class T>",
      "using is_unsigned_int =",
      "    typename std::conditional<(is_integral<T>::value && std::is_unsigned<T>::value) ||",
      "                                  is_unsigned_int128<T>::value,",
      "                              std::true_type, std::false_type>::type;",
      "template <class T>",
      "using to_unsigned = typename std::conditional<",
      "    is_signed_int128<T>::value, make_unsigned_int128<T>,",
      "    typename std::conditional<std::is_signed<T>::value, std::make_unsigned<T>,",
      "                              std::common_type<T>>::type>::type;",
      "template <class T> using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
      "template <class T> using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
      "template <class T> using to_unsigned_t = typename to_unsigned<T>::type;",
      "struct modint_base {};",
      "struct static_modint_base : modint_base {};",
      "template <class T> using is_modint = std::is_base_of<modint_base, T>;",
      "template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;",
      "template <int m, std::enable_if_t<(1 <= m)> * = nullptr> struct static_modint : static_modint_base {",
      "  using mint = static_modint;",
      "public:",
      "  static constexpr int mod() { return m; }",
      "  static mint raw(int v) {",
      "    mint x;",
      "    x._v = v;",
      "    return x;",
      "  }",
      "  static_modint() : _v(0) {}",
      "  template <class T, is_signed_int_t<T> * = nullptr> static_modint(T v) {",
      "    long long x = (long long)(v % (long long)(umod()));",
      "    if (x < 0)",
      "      x += umod();",
      "    _v = (unsigned int)(x);",
      "  }",
      "  template <class T, is_unsigned_int_t<T> * = nullptr> static_modint(T v) {",
      "    _v = (unsigned int)(v % umod());",
      "  }",
      "  unsigned int val() const { return _v; }",
      "  mint &operator++() {",
      "    _v++;",
      "    if (_v == umod())",
      "      _v = 0;",
      "    return *this;",
      "  }",
      "  mint &operator--() {",
      "    if (_v == 0)",
      "      _v = umod();",
      "    _v--;",
      "    return *this;",
      "  }",
      "  mint operator++(int) {",
      "    mint result = *this;",
      "    ++*this;",
      "    return result;",
      "  }",
      "  mint operator--(int) {",
      "    mint result = *this;",
      "    --*this;",
      "    return result;",
      "  }",
      "  mint &operator+=(const mint &rhs) {",
      "    _v += rhs._v;",
      "    if (_v >= umod())",
      "      _v -= umod();",
      "    return *this;",
      "  }",
      "  mint &operator-=(const mint &rhs) {",
      "    _v -= rhs._v;",
      "    if (_v >= umod())",
      "      _v += umod();",
      "    return *this;",
      "  }",
      "  mint &operator*=(const mint &rhs) {",
      "    unsigned long long z = _v;",
      "    z *= rhs._v;",
      "    _v = (unsigned int)(z % umod());",
      "    return *this;",
      "  }",
      "  mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
      "  mint operator+() const { return *this; }",
      "  mint operator-() const { return mint() - *this; }",
      "  mint pow(long long n) const {",
      "    assert(0 <= n);",
      "    mint x = *this, r = 1;",
      "    while (n) {",
      "      if (n & 1)",
      "        r *= x;",
      "      x *= x;",
      "      n >>= 1;",
      "    }",
      "    return r;",
      "  }",
      "  mint inv() const {",
      "    if (prime) {",
      "      assert(_v);",
      "      return pow(umod() - 2);",
      "    } else {",
      "      auto eg = inv_gcd(_v, m);",
      "      assert(eg.first == 1);",
      "      return eg.second;",
      "    }",
      "  }",
      "  friend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
      "  friend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
      "  friend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
      "  friend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
      "  friend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
      "  friend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
      "private:",
      "  unsigned int _v;",
      "  static constexpr unsigned int umod() { return m; }",
      "  static constexpr bool prime = is_prime<m>;",
      "};",
      "template <int id> struct dynamic_modint : modint_base {",
      "  using mint = dynamic_modint;",
      "public:",
      "  static int mod() { return (int)(bt.umod()); }",
      "  static void set_mod(int m) {",
      "    assert(1 <= m);",
      "    bt = barrett(m);",
      "  }",
      "  static mint raw(int v) {",
      "    mint x;",
      "    x._v = v;",
      "    return x;",
      "  }",
      "  dynamic_modint() : _v(0) {}",
      "  template <class T, is_signed_int_t<T> * = nullptr> dynamic_modint(T v) {",
      "    long long x = (long long)(v % (long long)(mod()));",
      "    if (x < 0)",
      "      x += mod();",
      "    _v = (unsigned int)(x);",
      "  }",
      "  template <class T, is_unsigned_int_t<T> * = nullptr> dynamic_modint(T v) {",
      "    _v = (unsigned int)(v % mod());",
      "  }",
      "  unsigned int val() const { return _v; }",
      "  mint &operator++() {",
      "    _v++;",
      "    if (_v == umod())",
      "      _v = 0;",
      "    return *this;",
      "  }",
      "  mint &operator--() {",
      "    if (_v == 0)",
      "      _v = umod();",
      "    _v--;",
      "    return *this;",
      "  }",
      "  mint operator++(int) {",
      "    mint result = *this;",
      "    ++*this;",
      "    return result;",
      "  }",
      "  mint operator--(int) {",
      "    mint result = *this;",
      "    --*this;",
      "    return result;",
      "  }",
      "  mint &operator+=(const mint &rhs) {",
      "    _v += rhs._v;",
      "    if (_v >= umod())",
      "      _v -= umod();",
      "    return *this;",
      "  }",
      "  mint &operator-=(const mint &rhs) {",
      "    _v += mod() - rhs._v;",
      "    if (_v >= umod())",
      "      _v -= umod();",
      "    return *this;",
      "  }",
      "  mint &operator*=(const mint &rhs) {",
      "    _v = bt.mul(_v, rhs._v);",
      "    return *this;",
      "  }",
      "  mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
      "  mint operator+() const { return *this; }",
      "  mint operator-() const { return mint() - *this; }",
      "  mint pow(long long n) const {",
      "    assert(0 <= n);",
      "    mint x = *this, r = 1;",
      "    while (n) {",
      "      if (n & 1)",
      "        r *= x;",
      "      x *= x;",
      "      n >>= 1;",
      "    }",
      "    return r;",
      "  }",
      "  mint inv() const {",
      "    auto eg = inv_gcd(_v, mod());",
      "    assert(eg.first == 1);",
      "    return eg.second;",
      "  }",
      "  friend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
      "  friend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
      "  friend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
      "  friend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
      "  friend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
      "  friend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
      "private:",
      "  unsigned int _v;",
      "  static barrett bt;",
      "  static unsigned int umod() { return bt.umod(); }",
      "};",
      "template <int id> barrett dynamic_modint<id>::bt(998244353);",
      "};"
    ]
  },
  "lazyseg": {
    "prefix": "lazyseg",
    "body": [
      "$0namespace lazyseg {",
      "unsigned int bit_ceil(unsigned int n) {",
      "  unsigned int x = 1;",
      "  while (x < (unsigned int)(n))",
      "    x *= 2;",
      "  return x;",
      "}",
      "int countr_zero(unsigned int n) { return __builtin_ctz(n); }",
      "constexpr int countr_zero_constexpr(unsigned int n) {",
      "  int x = 0;",
      "  while (!(n & (1 << x)))",
      "    x++;",
      "  return x;",
      "}",
      "template <class S, auto op, auto e, class F, auto mapping, auto composition, auto id>",
      "struct lazy_segtree {",
      "  static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>, \"op must work as S(S, S)\");",
      "  static_assert(std::is_convertible_v<decltype(e), std::function<S()>>, \"e must work as S()\");",
      "  static_assert(std::is_convertible_v<decltype(mapping), std::function<S(F, S)>>, \"mapping must work as F(F, S)\");",
      "  static_assert(std::is_convertible_v<decltype(composition), std::function<F(F, F)>>, \"compostiion must work as F(F, F)\");",
      "  static_assert(std::is_convertible_v<decltype(id), std::function<F()>>, \"id must work as F()\");",
      "public:",
      "  lazy_segtree() : lazy_segtree(0) {}",
      "  explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}",
      "  explicit lazy_segtree(const std::vector<S> &v) : _n(int32_t(v.size())) {",
      "    size = (int)bit_ceil((unsigned int)(_n));",
      "    log = countr_zero((unsigned int)size);",
      "    d = std::vector<S>(2 * size, e());",
      "    lz = std::vector<F>(size, id());",
      "    for (int i = 0; i < _n; i++)",
      "      d[size + i] = v[i];",
      "    for (int i = size - 1; i >= 1; i--) {",
      "      update(i);",
      "    }",
      "  }",
      "  void set(int p, S x) {",
      "    assert(0 <= p && p < _n);",
      "    p += size;",
      "    for (int i = log; i >= 1; i--)",
      "      push(p >> i);",
      "    d[p] = x;",
      "    for (int i = 1; i <= log; i++)",
      "      update(p >> i);",
      "  }",
      "  S get(int p) {",
      "    assert(0 <= p && p < _n);",
      "    p += size;",
      "    for (int i = log; i >= 1; i--)",
      "      push(p >> i);",
      "    return d[p];",
      "  }",
      "  S prod(int l, int r) {",
      "    assert(0 <= l && l <= r && r <= _n);",
      "    if (l == r)",
      "      return e();",
      "    l += size;",
      "    r += size;",
      "    for (int i = log; i >= 1; i--) {",
      "      if (((l >> i) << i) != l)",
      "        push(l >> i);",
      "      if (((r >> i) << i) != r)",
      "        push((r - 1) >> i);",
      "    }",
      "    S sml = e(), smr = e();",
      "    while (l < r) {",
      "      if (l & 1)",
      "        sml = op(sml, d[l++]);",
      "      if (r & 1)",
      "        smr = op(d[--r], smr);",
      "      l >>= 1;",
      "      r >>= 1;",
      "    }",
      "    return op(sml, smr);",
      "  }",
      "  S all_prod() { return d[1]; }",
      "  void apply(int p, F f) {",
      "    assert(0 <= p && p < _n);",
      "    p += size;",
      "    for (int i = log; i >= 1; i--)",
      "      push(p >> i);",
      "    d[p] = mapping(f, d[p]);",
      "    for (int i = 1; i <= log; i++)",
      "      update(p >> i);",
      "  }",
      "  void apply(int l, int r, F f) {",
      "    assert(0 <= l && l <= r && r <= _n);",
      "    if (l == r)",
      "      return;",
      "    l += size;",
      "    r += size;",
      "    for (int i = log; i >= 1; i--) {",
      "      if (((l >> i) << i) != l)",
      "        push(l >> i);",
      "      if (((r >> i) << i) != r)",
      "        push((r - 1) >> i);",
      "    }",
      "    {",
      "      int l2 = l, r2 = r;",
      "      while (l < r) {",
      "        if (l & 1)",
      "          all_apply(l++, f);",
      "        if (r & 1)",
      "          all_apply(--r, f);",
      "        l >>= 1;",
      "        r >>= 1;",
      "      }",
      "      l = l2;",
      "      r = r2;",
      "    }",
      "    for (int i = 1; i <= log; i++) {",
      "      if (((l >> i) << i) != l)",
      "        update(l >> i);",
      "      if (((r >> i) << i) != r)",
      "        update((r - 1) >> i);",
      "    }",
      "  }",
      "  template <bool (*g)(S)> int max_right(int l) {",
      "    return max_right(l, [](S x) { return g(x); });",
      "  }",
      "  template <class G> int max_right(int l, G g) {",
      "    assert(0 <= l && l <= _n);",
      "    assert(g(e()));",
      "    if (l == _n)",
      "      return _n;",
      "    l += size;",
      "    for (int i = log; i >= 1; i--)",
      "      push(l >> i);",
      "    S sm = e();",
      "    do {",
      "      while (l % 2 == 0)",
      "        l >>= 1;",
      "      if (!g(op(sm, d[l]))) {",
      "        while (l < size) {",
      "          push(l);",
      "          l = (2 * l);",
      "          if (g(op(sm, d[l]))) {",
      "            sm = op(sm, d[l]);",
      "            l++;",
      "          }",
      "        }",
      "        return l - size;",
      "      }",
      "      sm = op(sm, d[l]);",
      "      l++;",
      "    } while ((l & -l) != l);",
      "    return _n;",
      "  }",
      "  template <bool (*g)(S)> int min_left(int r) {",
      "    return min_left(r, [](S x) { return g(x); });",
      "  }",
      "  template <class G> int min_left(int r, G g) {",
      "    assert(0 <= r && r <= _n);",
      "    assert(g(e()));",
      "    if (r == 0)",
      "      return 0;",
      "    r += size;",
      "    for (int i = log; i >= 1; i--)",
      "      push((r - 1) >> i);",
      "    S sm = e();",
      "    do {",
      "      r--;",
      "      while (r > 1 && (r % 2))",
      "        r >>= 1;",
      "      if (!g(op(d[r], sm))) {",
      "        while (r < size) {",
      "          push(r);",
      "          r = (2 * r + 1);",
      "          if (g(op(d[r], sm))) {",
      "            sm = op(d[r], sm);",
      "            r--;",
      "          }",
      "        }",
      "        return r + 1 - size;",
      "      }",
      "      sm = op(d[r], sm);",
      "    } while ((r & -r) != r);",
      "    return 0;",
      "  }",
      "private:",
      "  int _n, size, log;",
      "  std::vector<S> d;",
      "  std::vector<F> lz;",
      "  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
      "  void all_apply(int k, F f) {",
      "    d[k] = mapping(f, d[k]);",
      "    if (k < size)",
      "      lz[k] = composition(f, lz[k]);",
      "  }",
      "  void push(int k) {",
      "    all_apply(2 * k, lz[k]);",
      "    all_apply(2 * k + 1, lz[k]);",
      "    lz[k] = id();",
      "  }",
      "};",
      "};"
    ]
  },
  "z_function": {
    "prefix": "zfunction",
    "body": [
      "vector<int> z_function(string s) {",
      "  int n = s.size();",
      "  vector<int> z(n);",
      "  int l = 0, r = 0;",
      "  for (int i = 1; i < n; i++) {",
      "    if (i < r) {",
      "      z[i] = min(r - i, z[i - l]);",
      "    }",
      "    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
      "      z[i]++;",
      "    }",
      "    if (i + z[i] > r) {",
      "      l = i;",
      "      r = i + z[i];",
      "    }",
      "  }",
      "  return z;",
      "}"
    ]
  },
  "hashing": {
    "prefix": "hashing",
    "body": [
      "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "#define uid(a, b) uniform_int_distribution<long long>(a, b)(rng)",
      "struct random_hashv {",
      "  const long long md = 1000000000000000003;",
      "  __int128_t base;",
      "  vector<__int128_t> powers, inv_powers;",
      "  random_hashv(int max_len) : powers(max_len), inv_powers(max_len), base(uid(1, md - 1)) {",
      "    for (int i = 0; i < max_len; i++)",
      "      powers[i] = i ? (powers[i - 1] * base) % md : 1;",
      "    for (int i = 0; i < max_len; i++) {",
      "      __int128_t a = powers[i], b = md, u = 1, v = 0;",
      "      while (b) {",
      "        __int128_t t = a / b;",
      "        a -= t * b, swap(a, b);",
      "        u -= t * v, swap(u, v);",
      "      }",
      "      inv_powers[i] = (u < 0 ? u + md : u);",
      "    }",
      "  }",
      "  void add(long long &hash, int i, long long multiplier) {",
      "    hash = (hash + (multiplier * powers[i]) % md) % md;",
      "  }",
      "  void remove(long long &hash, int i, long long multiplier) {",
      "    hash = (hash + md - ((multiplier * powers[i]) % md)) % md;",
      "  }",
      "  long long get_hash(const string &s, char default_char) {",
      "    long long hash = 0;",
      "    int sz = s.size();",
      "    for (int i = 0; i < sz; i++)",
      "      add(hash, i, (long long)s[i] - default_char);",
      "    return hash;",
      "  }",
      "};",
      "",
      "struct hashed {",
      "    int n;",
      "    int base_val;",
      "    vector<long long> prfx;",
      "    random_hashv hs;",
      "    template <typename T>",
      "    hashed(T container, int def)",
      "        : n(container.size()), prfx(n + 1), hs(n), base_val(def) {",
      "        for (int i = 0; i < n; ++i) {",
      "            hs.add(prfx[i + 1], i, container[i] - base_val);",
      "            prfx[i + 1] = (prfx[i + 1] + prfx[i]) % hs.md;",
      "        }",
      "    }",
      "    long long get(int l, int r) {",
      "        long long val = (prfx[r + 1] - prfx[l] + hs.md) % hs.md;",
      "        return (val * hs.inv_powers[l]) % hs.md;",
      "    }",
      "    bool cmp(int i, int j, int sz) {",
      "        assert(i + sz - 1 < n && j + sz - 1 < n);",
      "        return get(i, i + sz - 1) == get(j, j + sz - 1);",
      "    }",
      "};"
    ]
  },
  "combinations": {
    "prefix": "combi",
    "body": [
      "template <typename MI, const int SZ> struct combi {",
      "  static constexpr int M = SZ;",
      "  array<MI, M> fact, invfact;",
      "  constexpr combi() {",
      "    fact[0] = invfact[0] = 1;",
      "    for (int i = 1; i < M; i++)",
      "      fact[i] = fact[i - 1] * i;",
      "    invfact[M - 1] = fact[M - 1].inv();",
      "    for (int i = M - 2; i; i--)",
      "      invfact[i] = invfact[i + 1] * (i + 1);",
      "  }",
      "  inline MI C(int a, int b) {",
      "    if (a < 0 || b < 0 || a < b)",
      "      return 0;",
      "    return fact[a] * invfact[b] * invfact[a - b];",
      "  }",
      "};"
    ]
  },
  "number_theory": {
    "prefix": "numb",
    "body": [
      "template <const int SZ> struct numb {",
      "    static constexpr int M = SZ;",
      "    int pc = 0;",
      "    array<int, M> primes, lpf;",
      "    bitset<M> isPrime;",
      "    constexpr numb() {",
      "        for (int i = 2; i < M; ++i) {",
      "            if (!lpf[i]) {",
      "                primes[pc++] = i;",
      "                lpf[i] = i;",
      "                isPrime[i] = 1;",
      "            }",
      "            for (int j = 0;",
      "                 j < pc && 1LL * i * primes[j] < M && primes[j] <= lpf[i]; j++)",
      "                lpf[i * primes[j]] = primes[j];",
      "        }",
      "    }",
      "    pair<int, array<int, 30>> pfact(int V) {",
      "        array<int, 30> ret;",
      "        int sz = 0;",
      "        for (int p = lpf[V], cnt = 0; V > 1; p = lpf[V], cnt = 0) {",
      "            while (V % p == 0)",
      "                V /= p;",
      "            ret[sz++] = p;",
      "        }",
      "        return {sz, ret};",
      "    }",
      "    pair<int, array<pair<int, int>, 30>> pfact_with_frq(int V) {",
      "        array<pair<int, int>, 30> ret;",
      "        int sz = 0;",
      "        for (int p = lpf[V], cnt = 0; V > 1; p = lpf[V], cnt = 0) {",
      "            while (V % p == 0)",
      "                V /= p, ++cnt;",
      "            ret[sz++] = {p, cnt};",
      "        }",
      "        return {sz, ret};",
      "    }",
      "};"
    ]
  },
  "fast_power": {
    "prefix": "fpow",
    "body": [
      "long long fpow(long long x, long long n) {",
      "    long long result = 1;",
      "    for (; n > 0; n >>= 1, x *= x) {",
      "        if (n & 1)",
      "            result *= x;",
      "    }",
      "    return result;",
      "}"
    ]
  },
  "trie": {
    "prefix": "trie",
    "body": [
      "struct trie {",
      "  struct node {",
      "    int flag;",
      "    vector<int> nxt;",
      "    node(int entities) : flag(0), nxt(entities, -1) {}",
      "  };",
      "  vector<node> data;",
      "  int mxi, entities;",
      "  trie(int entities) : entities(entities), mxi(0) {",
      "    data.push_back(node(entities));",
      "  }",
      "  void add(auto element);",
      "  auto get(auto element);",
      "};"
    ]
  },
  "lca": {
    "prefix": "lca",
    "body": [
      "struct lowca {",
      "    int n, l, timer;",
      "    vector<vector<int>> adj;",
      "    vector<int> tin, tout;",
      "    vector<vector<int>> up;",
      "    vector<int> depth;",
      "    lowca(int n_, const vector<vector<int>> &g, int root_ = 0)",
      "        : n(n_), tin(n), tout(n), up(n), depth(n) {",
      "        adj = g;",
      "        preprocess(root_);",
      "    };",
      "  private:",
      "    void dfs(int v, int p, int dpt) {",
      "        depth[v] = dpt;",
      "        tin[v] = ++timer;",
      "        up[v][0] = p;",
      "        for (int i = 1; i <= l; ++i)",
      "            up[v][i] = up[up[v][i - 1]][i - 1];",
      "        for (int u : adj[v]) {",
      "            if (u != p)",
      "                dfs(u, v, dpt + 1);",
      "        }",
      "        tout[v] = ++timer;",
      "    }",
      "    void preprocess(int root) {",
      "        tin.resize(n);",
      "        tout.resize(n);",
      "        timer = 0;",
      "        l = ceil(log2(n));",
      "        up.assign(n, vector<int>(l + 1));",
      "        dfs(root, root, 0);",
      "    }",
      "  public:",
      "    bool is_ancestor(int u, int v) {",
      "        return tin[u] <= tin[v] && tout[u] >= tout[v];",
      "    }",
      "    int lca(int u, int v) {",
      "        if (is_ancestor(u, v))",
      "            return u;",
      "        if (is_ancestor(v, u))",
      "            return v;",
      "        for (int i = l; i >= 0; --i) {",
      "            if (!is_ancestor(up[u][i], v))",
      "                u = up[u][i];",
      "        }",
      "        return up[u][0];",
      "    }",
      "    int kth_ancestor(int u, int k) {",
      "        while (k) {",
      "            int t = __builtin_ctz(k);",
      "            u = up[u][t], k ^= 1 << t;",
      "        }",
      "        return u;",
      "    }",
      "    int kth_node_on_path(int u, int v, int k) {",
      "        int lc = lca(u, v);",
      "        int tn = depth[u] + depth[v] - 2 * depth[lc] + 1;",
      "        if (depth[u] - depth[lc] + 1 >= k)",
      "            return kth_ancestor(u, k - 1);",
      "        return kth_ancestor(v, tn - k);",
      "    }",
      "    int total_nodes_on_path(int u, int v) {",
      "        int lc = lca(u, v);",
      "        return depth[u] + depth[v] - 2 * depth[lc] + 1;",
      "    }",
      "    int distance(int u, int v) { return total_nodes_on_path(u, v) - 1; }",
      "};"
    ]
  },
  "custom_hash": {
    "prefix": "custom_hash",
    "body": [
      "struct custom_hash {",
      "  static uint64_t splitmix64(uint64_t x) {",
      "    // http://xorshift.di.unimi.it/splitmix64.c",
      "    x += 0x9e3779b97f4a7c15;",
      "    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "    return x ^ (x >> 31);",
      "  }",
      "  size_t operator()(uint64_t x) const {",
      "    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "    return splitmix64(x + FIXED_RANDOM);",
      "  }",
      "};"
    ]
  }
}
